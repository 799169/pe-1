#ifndef __PE_MISC_H__
#define __PE_MISC_H__

#include "pe_base"

class GaussianEliminationMod2 {
 public:
  void init(int r, int c) {
    row = r;
    col = c;
    data.resize(row);
    colex = (col + 63) >> 6;
    for (int i = 0; i < row; ++i) {
      vector<uint64>(colex, 0).swap(data[i]);
    }
  }

  void fillZero() {
    for (auto& iter : data) {
      fill(iter.begin(), iter.end(), 0);
    }
  }

  int at(int i, int j) const {
    const int idx = j >> 6;
    const int offset = j & 63;
    return (data[i][idx] >> offset) & 1;
  }

  void set(int i, int j, int v) {
    const int idx = j >> 6;
    const int offset = j & 63;
    if (v) {
      data[i][idx] |= 1LL << offset;
    } else {
      data[i][idx] &= ~(1LL << offset);
    }
  }

  void change(int i, int j) { set(i, j, at(i, j) ^ 1); }

  int reduce() {
    x = y = 0;
    while (x < row && y < col) {
      int id = x;
      while (id < row && at(id, y) == 0) ++id;
      if (id == row) {
        ++y;
        continue;
      }
      if (id != x) {
        data[id].swap(data[x]);
      }
      for (int i = x + 1; i < row; ++i) {
        if (at(i, y) == 0) continue;
        for (int j = y >> 6; j < colex; ++j) data[i][j] ^= data[x][j];
      }
      ++x, ++y;
    }
    return rank();
  }

  int rank() const { return x; }

  vector<vector<uint64>> data;
  int row, col, colex;
  int x, y;
};

class GaussianEliminationSolver {
 public:
  void init(int r, int c) {
    row = r;
    col = c;
    data.resize(row);
    for (int i = 0; i < r; ++i) {
      vector<double>(col + 1, 0).swap(data[i]);
    }
  }

  void fillZero() { fill(0); }

  void fill(double v) {
    for (auto& iter : data) {
      std::fill(iter.begin(), iter.end(), v);
    }
  }

  double& at(int i, int j) { return data[i][j]; }

  vector<double>& rowData(int i) { return data[i]; }

  static int dbsgn(double x) {
    if (fabs(x) < 1e-10) {
      return 0;
    }
    return x > 0 ? 1 : -1;
  }

  int reduce() {
    x = y = 0;
    while (x < row && y < col) {
      int bestId = x;
      double bestV = fabs(at(x, y));
      for (int i = x + 1; i < row; ++i) {
        auto now = fabs(at(i, y));
        if (now > bestV) {
          bestId = i;
          bestV = now;
        }
      }
      if (dbsgn(bestV) == 0) {
        ++y;
        continue;
      }
      if (bestId != x) {
        data[bestId].swap(data[x]);
      }
      for (int i = x + 1; i < row; ++i) {
        if (dbsgn(at(i, y)) == 0) continue;
        const double coe = -at(i, y) / at(x, y);
        for (int j = y; j <= col; ++j) data[i][j] += data[x][j] * coe;
      }
      ++x, ++y;
    }
    return rank();
  }

  const vector<double>& solve() {
    reduce();
    PE_ASSERT(rank() == row);
    ans.resize(row);
    for (int i = row - 1; i >= 0; --i) {
      data[i][col] /= data[i][i];
      data[i][i] = 1;
      const double v = data[i][col];
      ans[i] = v;
      for (int j = i - 1; j >= 0; --j) {
        data[j][col] -= v * data[j][i];
      }
    }
    return ans;
  }

  int rank() const { return x; }

  vector<vector<double>> data;
  vector<double> ans;

  int row, col;
  int x, y;
};

// Returns the number of (x, y) where
// x^2+y^2<=n and x >= 0 and y >= 0
SL int64 count_pt_in_circle_q1(int64 n) {
  struct Pt {int64 x, y;};
  const int64 m = sqrti(n);
  stack<Pt> stk;
  stk.push({0, 1});
  int64 vx = 1, vy = 0;
  int64 A = 0, B = 0;
  int64 x = 0, y = m;
  while (!stk.empty()) {
    while (x + vx <= m && y - vy >= 0 && sq(x+vx) + sq(y-vy) <= n) {
      x += vx;
      y -= vy;
      A += vx * (2 * y + vy);
      ++B;
    }
    if (x >= m) break;
    int64 cx, cy;
    cx = stk.top().x;
    cy = stk.top().y;
    stk.pop();
    int fnd = 0;
    while (!fnd) {
      while (x + cx <= m && y - cy >= 0 && sq(x+cx) + sq(y-cy) <= n) {
        stk.push({cx, cy});
        cx += vx, cy += vy;
      }
      vx = cx, vy = cy;
      if (stk.empty()) {
        fnd = 1;
        break;
      }
      
      cx = stk.top().x;
      cy = stk.top().y;
      stk.pop();
      int64 lastV = -1;
      for (;;) {
        if (x + vx + cx <= m && y-vy-cy>=0&&sq(x+vx+cx)+sq(y-vy-cy) <= n) {
          stk.push({cx, cy});
          cx += vx, cy += vy;
          break;
        }
        int64 currV = sq(x+vx+2*cx) + sq(y-vy-2*cy);
        //if (x + vx + 2 * cx > m || y - vy - 2*cy < 0 || lastV != -1 && currV > lastV) {
        if (cx*(x+vx+cx)>=cy*(y-vy-cy)) {
          vx = cx, vy = cy;
          fnd = 1;
          break;
        }
        lastV = currV;
        vx += cx;
        vy += cy;
      }
    }
  }

  const int64 BD = B + m + x + (y - 1) + 1;
  const int64 I = (A - BD + 2) / 2;
  int64 ret = I + BD;
  for (int64 i = x + 1; i <= m; ++i) {
    ret += sqrti(n-sq(i)) + 1;
  }
  return ret;
}

SL int64 count_pt_in_circle(int64 n) {
  const int64 m = sqrti(n);
  const int64 t = count_pt_in_circle_q1(n);
  return (t - m) * 4 + 1;
}

SL int64 count_pt_in_circle_q1_bf(int64 n) {
  const int64 m = sqrti(n);
  int64 ret = 0;
  for (int64 i = 0; i <= m; ++i) {
    ret += sqrti(n-sq(i)) + 1;
  }
  return ret;
}

SL int64 count_pt_in_circle_bf(int64 n) {
  const int64 m = sqrti(n);
  const int64 t = count_pt_in_circle_q1_bf(n);
  return (t - m) * 4 + 1;
}
#endif
