#ifndef __PE_MAT__
#define __PE_MAT__

#include "pe_base"
#include "pe_mod"

template <typename T, int D>
SL void mat_mul_mat(T (*a)[D], T (*b)[D], T (*c)[D], int N = D) {
  for (int i = 0; i < N; ++i)
    for (int j = 0; j < N; ++j) {
      T s = 0;
      for (int k = 0; k < N; ++k) s += a[i][k] * b[k][j];
      c[i][j] = s;
    }
}

template <typename T>
SL void mat_mul_mat(T* aa, T* bb, T* cc, int N) {
  for (int i = 0; i < N; ++i)
    for (int j = 0; j < N; ++j) {
      T* a = aa + i * N;
      T* c = cc + i * N;
      T s = 0;
      for (int k = 0; k < N; ++k) s += a[k] * (bb + k * N)[j];
      c[j] = s;
    }
}

template <typename T, int D>
SL void mat_mul_vec(T (*a)[D], T (*b)[D], T (*c)[D], int N = D) {
  for (int i = 0; i < N; ++i) {
    T s = 0;
    for (int k = 0; k < N; ++k) s += a[i][k] * b[k][0];
    c[i][0] = s;
  }
}

template <typename T, int D>
SL void mat_mul_vec(T (*a)[D], T* b, T* c, int N = D) {
  for (int i = 0; i < N; ++i) {
    T s = 0;
    for (int k = 0; k < N; ++k) s += a[i][k] * b[k];
    c[i] = s;
  }
}

template <typename T>
SL void mat_mul_vec(T* aa, T* b, T* c, int N) {
  for (int i = 0; i < N; ++i) {
    T* a = aa + i * N;
    T s = 0;
    for (int k = 0; k < N; ++k) s += a[k] * b[k];
    c[i] = s;
  }
}

template <typename T, int D>
SL void mat_mul_mat_mod(T (*a)[D], T (*b)[D], T (*c)[D], int64 mod, int N = D) {
  for (int i = 0; i < N; ++i)
    for (int j = 0; j < N; ++j) {
      int64 s = 0;
      for (int k = 0; k < N; ++k) {
        s += mul_mod(a[i][k], b[k][j], mod);
        if (s >= mod) s -= mod;
      }
      c[i][j] = s % mod;
    }
}

template <typename T>
SL void mat_mul_mat_mod(T* aa, T* bb, T* cc, int64 mod, int N) {
  for (int i = 0; i < N; ++i)
    for (int j = 0; j < N; ++j) {
      T* a = aa + i * N;
      T* c = cc + i * N;
      int64 s = 0;
      for (int k = 0; k < N; ++k) {
        s += mul_mod(a[k], (bb + k * N)[j], mod);
        if (s >= mod) s -= mod;
      }
      c[j] = s % mod;
    }
}

template <typename T, int D>
SL void mat_mul_vec_mod(T (*a)[D], T (*b)[D], T (*c)[D], int64 mod, int N = D) {
  for (int i = 0; i < N; ++i) {
    int64 s = 0;
    for (int k = 0; k < N; ++k) {
      s += mul_mod(a[i][k], b[k][0], mod);
      if (s >= mod) s -= mod;
    }
    c[i][0] = s;
  }
}

template <typename T, int D>
SL void mat_mul_vec_mod(T (*a)[D], T* b, T* c, int64 mod, int N = D) {
  for (int i = 0; i < N; ++i) {
    int64 s = 0;
    for (int k = 0; k < N; ++k) {
      s += mul_mod(a[i][k], b[k], mod);
      if (s >= mod) s -= mod;
    }
    c[i] = s;
  }
}

template <typename T>
SL void mat_mul_vec_mod(T* aa, T* b, T* c, int64 mod, int N) {
  for (int i = 0; i < N; ++i) {
    T* a = aa + i * N;
    int64 s = 0;
    for (int k = 0; k < N; ++k) {
      s += mul_mod(a[k], b[k], mod);
      if (s >= mod) s -= mod;
    }
    c[i] = s;
  }
}

#if ENABLE_EIGEN

template <typename _Scalar, int _Rows, int _Cols>
SL Eigen::Matrix<_Scalar, _Rows, _Cols> power_mod_impl(
    const Eigen::Matrix<_Scalar, _Rows, _Cols>& x, int64 n, int64 mod,
    NModNumberOrNModNumberDIndicator<0>) {
  typedef Eigen::Matrix<_Scalar, _Rows, _Cols> MatrixT;
  auto fixmod = [=](MatrixT& m) {
    const auto r = m.rows();
    const auto c = m.cols();
    for (int i = 0; i < r; ++i)
      for (int j = 0; j < c; ++j) {
        m(i, j) = regulate_mod(m(i, j), mod);
      }
  };
  const int K = x.rows();

  MatrixT e = MatrixT::Identity(K, K);

  MatrixT y = x;
  fixmod(y);
  for (; n; n >>= 1) {
    // cout << "n = " << n << endl;
    if (n & 1) {
      e *= y;
      fixmod(e);
    }
    if (n > 1) {
      y *= y;
      fixmod(y);
    }
  }
  return e;
}

template <typename _Scalar, int _Rows, int _Cols>
SL Eigen::Matrix<_Scalar, _Rows, _Cols> power_mod_impl(
    const Eigen::Matrix<_Scalar, _Rows, _Cols>& x, int64 n, int64 /*mod*/,
    NModNumberOrNModNumberDIndicator<1>) {
  typedef Eigen::Matrix<_Scalar, _Rows, _Cols> MatrixT;
  auto fixmod = [=](MatrixT& m) {
    const auto r = m.rows();
    const auto c = m.cols();
    for (int i = 0; i < r; ++i)
      for (int j = 0; j < c; ++j) {
        m(i, j).fix_value();
      }
  };

  const int K = x.rows();

  MatrixT e = MatrixT::Identity(K, K);
  MatrixT y = x;

  for (; n; n >>= 1) {
    // cout << "n = " << n << endl;
    if (n & 1) {
      e *= y;
      fixmod(e);
    }
    if (n > 1) {
      y *= y;
      fixmod(y);
    }
  }
  return e;
}

template <typename _Scalar, int _Rows, int _Cols>
SL Eigen::Matrix<_Scalar, _Rows, _Cols> power_mod(
    const Eigen::Matrix<_Scalar, _Rows, _Cols>& x, int64 n, int64 mod) {
  return power_mod_impl(
      x, n, mod,
      NModNumberOrNModNumberDIndicator < IsNModNumber<_Scalar>::result ||
          IsNModNumberD<_Scalar>::result > ());
}

template <typename _Scalar, int _Rows, int _Cols, typename _ScalarV>
SL vector<_ScalarV> power_mod_impl(
    const Eigen::Matrix<_Scalar, _Rows, _Cols>& x, int64 n,
    const vector<_ScalarV>& v, int64 mod, NModNumberOrNModNumberDIndicator<0>) {
  static_assert(std::is_same<_Scalar, _ScalarV>::value,
                "Matrix's element type must be the same as vector's");
  typedef Eigen::Matrix<_Scalar, _Rows, _Cols> MatrixT;
  auto fixmod = [=](MatrixT& m) {
    const auto r = m.rows();
    const auto c = m.cols();
    for (int i = 0; i < r; ++i)
      for (int j = 0; j < c; ++j) {
        m(i, j) = regulate_mod(m(i, j), mod);
      }
  };
  const int K = x.rows();

  vector<_ScalarV> result(v);
  for (auto& i : result) i = regulate_mod(i, mod);

  MatrixT y = x;
  fixmod(y);
  for (; n; n >>= 1) {
    // cout << "n = " << n << endl;
    if (n & 1) {
      vector<_ScalarV> temp(K, 0);
      for (int i = 0; i < K; ++i) {
        _ScalarV s = 0;
        for (int j = 0; j < K; ++j) {
          s += y(i, j) * result[j];
        }
        temp[i] = s % mod;
      }
      result = std::move(temp);
    }
    if (n > 1) {
      y *= y;
      fixmod(y);
    }
  }
  return result;
}

template <typename _Scalar, int _Rows, int _Cols, typename _ScalarV>
SL vector<_ScalarV> power_mod_impl(
    const Eigen::Matrix<_Scalar, _Rows, _Cols>& x, int64 n,
    const vector<_ScalarV>& v, int64 /*mod*/,
    NModNumberOrNModNumberDIndicator<1>) {
  static_assert(std::is_same<_Scalar, _ScalarV>::value,
                "Matrix's element type must be the same as vector's");
  typedef Eigen::Matrix<_Scalar, _Rows, _Cols> MatrixT;
  auto fixmod = [=](MatrixT& m) {
    const auto r = m.rows();
    const auto c = m.cols();
    for (int i = 0; i < r; ++i)
      for (int j = 0; j < c; ++j) {
        m(i, j).fix_value();
      }
  };

  const int K = x.rows();

  vector<_ScalarV> result(v);
  MatrixT y = x;

  for (; n; n >>= 1) {
    // cout << "n = " << n << endl;
    if (n & 1) {
      vector<_ScalarV> temp(K, 0);
      for (int i = 0; i < K; ++i) {
        _ScalarV s = 0;
        for (int j = 0; j < K; ++j) {
          s += y(i, j) * result[j];
        }
        s.fix_value();
        temp[i] = s;
      }
      result = std::move(temp);
    }
    if (n > 1) {
      y *= y;
      fixmod(y);
    }
  }
  return result;
}

template <typename _Scalar, int _Rows, int _Cols, typename _ScalarV>
SL vector<_ScalarV> power_mod(const Eigen::Matrix<_Scalar, _Rows, _Cols>& x,
                              int64 n, const vector<_ScalarV>& v, int64 mod) {
  return power_mod_impl(
      x, n, v, mod,
      NModNumberOrNModNumberDIndicator < IsNModNumber<_Scalar>::result ||
          IsNModNumberD<_Scalar>::result > ());
}

/**
 * Helper method to avoid writing type explicitly.
 * auto res = power_mod<1000000007>([=](auto& m) {
 *   m(0, 0) = 1;
 *   m(0, 1) = 1;
 *   m(1, 0) = 1;
 * }, 2, 100000);
 * or
 * auto res = power_mod<1000000007>([=](auto& m, auto& v) {
 *   m(0, 0) = 1;
 *   m(0, 1) = 1;
 *   m(1, 0) = 1;
 *   v[0] = 1;
 *   v[1] = 1;
 * }, 2, 100000);
 */
// If int128 is available, use int128 as the matrix element type
// and the vector element type.
// Otherwise, use NModNumber6464<mod> and so the mod value must
// be specified as template argument which is required to be
// a compiling time constant.
#if PE_HAS_INT128
SL vector<int64> power_mod(
    const function<
        void(Eigen::Matrix<int128, Eigen::Dynamic, Eigen::Dynamic>& mat,
             vector<int128>& v)>& init,
    const int K, int64 n, int64 mod) {
  typedef int128 ScalarT;
  typedef Eigen::Matrix<ScalarT, Eigen::Dynamic, Eigen::Dynamic> MatrixT;

  vector<ScalarT> v(K, 0);
  MatrixT m = MatrixT::Zero(K, K);

  init(m, v);

  auto t = power_mod(m, n, v, mod);

  vector<int64> res(K, 0);
  for (int i = 0; i < K; ++i) res[i] = t[i];

  return res;
}

template <int64 mod>
SL vector<int64> power_mod(
    const function<
        void(Eigen::Matrix<int128, Eigen::Dynamic, Eigen::Dynamic>& mat,
             vector<int128>& v)>& init,
    const int K, int64 n) {
  return power_mod(init, K, n, mod);
}

SL Eigen::Matrix<int64, Eigen::Dynamic, Eigen::Dynamic> power_mod(
    const function<
        void(Eigen::Matrix<int128, Eigen::Dynamic, Eigen::Dynamic>& mat)>& init,
    const int K, int64 n, int64 mod) {
  typedef int128 ScalarT;
  typedef Eigen::Matrix<ScalarT, Eigen::Dynamic, Eigen::Dynamic> MatrixT;

  MatrixT m = MatrixT::Zero(K, K);

  init(m);

  auto t = power_mod(m, n, mod);

  Eigen::Matrix<int64, Eigen::Dynamic, Eigen::Dynamic> res(K, K);
  for (int i = 0; i < K; ++i)
    for (int j = 0; j < K; ++j) res(i, j) = static_cast<int64>(t(i, j));

  return res;
}

template <int64 mod>
SL Eigen::Matrix<int64, Eigen::Dynamic, Eigen::Dynamic> power_mod(
    const function<
        void(Eigen::Matrix<int128, Eigen::Dynamic, Eigen::Dynamic>& mat)>& init,
    const int K, int64 n) {
  return power_mod(init, K, n, mod);
}
#else
template <int64 mod>
SL vector<int64> power_mod(
    const function<void(
        Eigen::Matrix<NModNumber6464<mod>, Eigen::Dynamic, Eigen::Dynamic>& mat,
        vector<NModNumber6464<mod> >& v)>& init,
    const int K, int64 n) {
  typedef NModNumber6464<mod> ScalarT;
  typedef Eigen::Matrix<ScalarT, Eigen::Dynamic, Eigen::Dynamic> MatrixT;

  vector<ScalarT> v(K, 0);
  MatrixT m = MatrixT::Zero(K, K);

  init(m, v);

  auto t = power_mod(m, n, v, mod);

  vector<int64> res(K, 0);
  for (int i = 0; i < K; ++i) res[i] = t[i].value();

  return res;
}

template <int64 mod>
SL Eigen::Matrix<int64, Eigen::Dynamic, Eigen::Dynamic> power_mod(
    const function<void(Eigen::Matrix<NModNumber6464<mod>, Eigen::Dynamic,
                                      Eigen::Dynamic>& mat)>& init,
    const int K, int64 n) {
  typedef NModNumber6464<mod> ScalarT;
  typedef Eigen::Matrix<ScalarT, Eigen::Dynamic, Eigen::Dynamic> MatrixT;

  MatrixT m = MatrixT::Zero(K, K);

  init(m);

  auto t = power_mod(m, n, mod);

  Eigen::Matrix<int64, Eigen::Dynamic, Eigen::Dynamic> res(K, K);
  for (int i = 0; i < K; ++i)
    for (int j = 0; j < K; ++j) res(i, j) = t(i, j).value();

  return res;
}
#endif

using Mat64 = Eigen::Matrix<int64, Eigen::Dynamic, Eigen::Dynamic>;

template <int64 mod>
using MatM = Eigen::Matrix<NModNumber6464<mod>, Eigen::Dynamic, Eigen::Dynamic>;

using MatMD = Eigen::Matrix<NModNumberD6464, Eigen::Dynamic, Eigen::Dynamic>;

#if PE_HAS_INT128
using Mat128 = Eigen::Matrix<int128, Eigen::Dynamic, Eigen::Dynamic>;

template <int64 mod>
using MatML =
    Eigen::Matrix<NModNumberL128<mod>, Eigen::Dynamic, Eigen::Dynamic>;

using MatMDL = Eigen::Matrix<NModNumberDL128, Eigen::Dynamic, Eigen::Dynamic>;
#endif

#endif  // end ENABLE_EIGEN

#endif
