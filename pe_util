#ifndef __PE_UTIL_H__
#define __PE_UTIL_H__

#include "pe_base"

typedef chrono::high_resolution_clock pe_clock_t;
typedef pe_clock_t::time_point time_point_t;
typedef pe_clock_t::duration duration_t;
typedef pe_clock_t::period period_t;

static const int64 MILLI_SEC_CLOCKS = period_t::den / milli::den;
static const int64 SEC_CLOCKS = period_t::den;
static const int64 MIN_CLOCKS = SEC_CLOCKS * 60;
static const int64 HOUR_CLOCKS = MIN_CLOCKS * 60;
static const int64 DAY_CLOCKS = HOUR_CLOCKS * 24;

class TimeDelta {
 public:
  TimeDelta(duration_t duration = duration_t::zero()) : duration_(duration) {}

  int64 native_time() const { return duration_.count(); }
  double to_seconds() const { return 1. * duration_.count() / SEC_CLOCKS; }
  double to_minutes() const { return 1. * duration_.count() / MIN_CLOCKS; }
  double to_hours() const { return 1. * duration_.count() / HOUR_CLOCKS; }
  double to_days() const { return 1. * duration_.count() / DAY_CLOCKS; }
  string format() const {
    char temp[128];
    const int64 nano_seconds = duration_.count();
    const int64 day = nano_seconds / DAY_CLOCKS;
    const int hour = static_cast<int>(nano_seconds % DAY_CLOCKS / HOUR_CLOCKS);
    const int min = static_cast<int>(nano_seconds % HOUR_CLOCKS / MIN_CLOCKS);
    const int sec = static_cast<int>(nano_seconds % MIN_CLOCKS / SEC_CLOCKS);
    const int msec =
        static_cast<int>(nano_seconds % SEC_CLOCKS / MILLI_SEC_CLOCKS);
    sprintf(temp, "%I64d:%02d:%02d:%02d.%03d", day, hour, min, sec, msec);
    return temp;
  }

  static TimeDelta from_millisecond(int64 t) {
    return duration_t(t * MILLI_SEC_CLOCKS);
  }
  static TimeDelta from_second(int64 t) { return duration_t(t * SEC_CLOCKS); }
  static TimeDelta from_minute(int64 t) { return duration_t(t * MIN_CLOCKS); }
  static TimeDelta from_hour(int64 t) { return duration_t(t * HOUR_CLOCKS); }
  static TimeDelta from_day(int64 t) { return duration_t(t * DAY_CLOCKS); }

  bool operator>(const TimeDelta& o) const { return duration_ > o.duration_; }
  bool operator>=(const TimeDelta& o) const { return duration_ >= o.duration_; }
  bool operator==(const TimeDelta& o) const { return duration_ == o.duration_; }
  bool operator<(const TimeDelta& o) const { return duration_ < o.duration_; }
  bool operator<=(const TimeDelta& o) const { return duration_ <= o.duration_; }

 private:
  duration_t duration_;
};

class TimeRecorder {
 public:
  TimeRecorder() : last_time_(pe_clock_t::now()) {}

  int64 record() {
    last_time_ = pe_clock_t::now();
    return last_time_.time_since_epoch().count();
  }

  TimeDelta elapsed() const { return pe_clock_t::now() - last_time_; }

 private:
  time_point_t last_time_;
};

template <typename T>
class SavePolicy {
 public:
  SavePolicy()
      : auto_save_(true),
        dirty_(0),
        dirty_limit_(10),
        time_limit_(TimeDelta::from_second(10)) {
    on_saved();
  }

  ~SavePolicy() {}

  void enable_auto_save(bool enable = true) { auto_save_ = enable; }

  void set_dirty_limit(int d) { dirty_limit_ = d; }

  void disable_dirty_limit() { dirty_limit_ = 2000000000; }

  void set_time_limit(TimeDelta t) { time_limit_ = t; }

  void disable_time_limit() { time_limit_ = TimeDelta::from_day(10); }

  void on_closing() {
    if (dirty_ > 0) {
      static_cast<T&>(*this).save();
    }
  }

  void on_updated() {
    ++dirty_;
    if (auto_save_ &&
        (tr_.elapsed() >= time_limit_ || dirty_ >= dirty_limit_)) {
      static_cast<T&>(*this).save();
    }
  }

  void on_saved() {
    tr_.record();
    dirty_ = 0;
  }

 private:
  bool auto_save_;
  int dirty_;
  int dirty_limit_;
  TimeDelta time_limit_;
  TimeRecorder tr_;
};

class KVPersistance : public SavePolicy<KVPersistance> {
 public:
  KVPersistance(const string& path, bool check = false)
      : path_(path), check_(check) {
    load();
  }

  ~KVPersistance() { on_closing(); }

  void load(bool check = false) {
    on_saved();

    FILE* fp = fopen(path_.c_str(), "r");
    if (!fp) return;

    vector<pair<int64, int64> > vec;
    int64 k, v;
    while (fscanf(fp, "%I64d %I64d", &k, &v) == 2) vec.emplace_back(k, v);
    fclose(fp);

    if (check || check_) {
      stable_sort(vec.begin(), vec.end());
      const int n = static_cast<int>(vec.size());
      for (int i = 1; i < n; ++i)
        if (vec[i - 1].first == vec[i].first) {
          if (vec[i - 1].second != vec[i].second) {
            fprintf(stderr, "key = %I64d, value = %I64d, %I64d\n", vec[i].first,
                    vec[i - 1].second, vec[i].second);
            assert(0);
          }
        }
    }
    kv_ = std::move(map<int64, int64>(vec.begin(), vec.end()));
  }

  void save() {
    FILE* fp = fopen(path_.c_str(), "w");
    if (!fp) return;
    for (auto& iter : kv_) {
      fprintf(fp, "%I64d %I64d\n", iter.first, iter.second);
    }
    fclose(fp);
    string cmd = "copy " + path_ + " " + path_ + ".bak /Y";
    system(cmd.c_str());
    on_saved();
  }

  void set(int64 key, int64 v) {
    bool skip = false;
    if (check_) {
      auto where = kv_.find(key);
      if (where != kv_.end()) {
        if (where->second != v) {
          fprintf(stderr, "invalid set: key = %I64d, value = %I64d, %I64d\n",
                  key, where->second, v);
          assert(0);
        } else {
          skip = true;
        }
      }
    }
    if (skip) return;

    kv_[key] = v;

    on_updated();
  }

  map<int64, int64>& storage() { return kv_; }

  int64 size() const { return kv_.size(); }

  void visit(const function<bool(int64, int64)>& f) {
    for (auto& iter : kv_) {
      if (!f(iter.first, iter.second)) break;
    }
  }

 private:
  string path_;
  bool check_;
  map<int64, int64> kv_;
};

class time_usage {
 public:
  ~time_usage() {
    fprintf(stderr, "time usage: %s\n", tr_.elapsed().format().c_str());
  }

 private:
  TimeRecorder tr_;
};

#ifndef PE_TEST_MODE
static time_usage __time_usage;
#endif

#endif
