#ifndef __PE_THREADS_H__
#define __PE_THREADS_H__

#include <windows.h>
#include <process.h>
#include <cstdio>
#include <string>
#include <cassert>
#include <algorithm>
using namespace std;

struct TaskContext
{
  int task_id;
  int worker_idx;
};

class Threads
{
enum
{
  min_thread = 1,
  max_thread = 64,
  max_tasks = 2000000,
  stop_task_id = 2000000000
};

typedef void (*worker_pointer)(int task_id);
typedef void (*worker_pointer_ext)(TaskContext ctx);
struct ThreadContext
{
  int idx;
  worker_pointer worker;
  worker_pointer_ext worker_ext;
  Threads* host;
};

public:
Threads() : threads_count(0), thread_worker(NULL), thread_worker_ext(NULL), p(0), q(0)
{
  memset(threads_context, 0, sizeof threads_context);
}

void init(worker_pointer worker, const int threads = 3, const int stack = 100*(1<<20))
{
  assert(thread_worker == NULL && thread_worker_ext == NULL);
  
  p = q = 0;
  InitializeCriticalSection(&request_access);
  has_request = CreateEvent(NULL, FALSE, FALSE, NULL);
  has_result = CreateEvent(NULL, FALSE, FALSE, NULL);
  threads_count = max(threads, (int)min_thread);
  threads_count = min(threads_count, (int)max_thread);
  thread_worker = worker;
  for (int i = 0; i < threads_count; ++i)
  {
    threads_context[i].idx = i;
    threads_context[i].worker = thread_worker;
    threads_context[i].worker_ext = thread_worker_ext;
    threads_context[i].host = this;
    threads_handle[i] = (HANDLE)_beginthreadex(NULL, max(stack, 100*(1<<20)), work_thread, (void*)&threads_context[i], 0, NULL);
  }
  start = GetTickCount();
}

void init(worker_pointer_ext worker_ext, const int threads = 3, const int stack = 100*(1<<20))
{
  assert(thread_worker == NULL && thread_worker_ext == NULL);
  
  p = q = 0;
  InitializeCriticalSection(&request_access);
  has_request = CreateEvent(NULL, FALSE, FALSE, NULL);
  has_result = CreateEvent(NULL, FALSE, FALSE, NULL);
  threads_count = max(threads, (int)min_thread);
  threads_count = min(threads_count, (int)max_thread);
  thread_worker_ext = worker_ext;
  for (int i = 0; i < threads_count; ++i)
  {
    threads_context[i].idx = i;
    threads_context[i].worker = thread_worker;
    threads_context[i].worker_ext = thread_worker_ext;
    threads_context[i].host = this;
    threads_handle[i] = (HANDLE)_beginthreadex(NULL, max(stack, 100*(1<<20)), work_thread, (void*)&threads_context[i], 0, NULL);
  }
  start = GetTickCount();
}

void wait_for_queue(int max_request = -1)
{
  if (max_request == -1) max_request = threads_count;
  for (;;)
  {
    if (get_request_count() < max_request) break;
    WaitForSingleObject(has_result, 500);
  }
}

void add_request(const int id)
{
  EnterCriticalSection(&request_access);
  task_que[q++] = id;
  LeaveCriticalSection(&request_access);
  SetEvent(has_request);
}

void wait_for_end()
{
  add_request(stop_task_id);
  WaitForMultipleObjects(threads_count, threads_handle, TRUE, INFINITE);
  for (int i = 0; i < threads_count; ++i) CloseHandle(threads_handle[i]);
  CloseHandle(has_result);
  CloseHandle(has_request);
  DeleteCriticalSection(&request_access);
  end = GetTickCount();
  fprintf(stderr, "time : %u\n", (unsigned)(end - start));
}

public:

void lock()
{
  EnterCriticalSection(&request_access);
}

void unlock()
{
  LeaveCriticalSection(&request_access);
}

bool get_next_request(int& id, int inc)
{
  id = -1;
  EnterCriticalSection(&request_access);
  if (p < q)
  {
    id = task_que[p];
    if (id != stop_task_id) p += inc;
  }
  LeaveCriticalSection(&request_access);
  return id != -1;
}

int get_request_count()
{
  int ret = 0;
  EnterCriticalSection(&request_access);
  ret = q - p;
  LeaveCriticalSection(&request_access);
  return ret;
}

void work(ThreadContext thread_context)
{
  for (;;)
  {
    int id = -1;
    if (get_next_request(id, 0) == false)
    {
      DWORD wait_result = WaitForSingleObject(has_request, INFINITE);
      if (wait_result != WAIT_OBJECT_0) continue;
    }
    if (get_next_request(id, 1) == false) continue;
    if (id == stop_task_id) {SetEvent(has_request);break;}
    if (thread_context.worker) (*thread_context.worker)(id);
    if (thread_context.worker_ext)
    {
      TaskContext ctx;
      ctx.task_id = id;
      ctx.worker_idx = thread_context.idx;
      (*thread_context.worker_ext)(ctx);
    }
    SetEvent(has_result);
  }
}

static unsigned int __stdcall work_thread(void* p)
{
  ThreadContext context_copy = *(ThreadContext*)p;
  context_copy.host->work(context_copy);
  return 0;
}

private:
  DWORD start, end;

private:
  int threads_count;
  
  HANDLE threads_handle[max_thread];
  ThreadContext threads_context[max_thread];
  
  HANDLE has_request;
  HANDLE has_result;
  CRITICAL_SECTION request_access;
  worker_pointer thread_worker;
  worker_pointer_ext thread_worker_ext;

  int task_que[max_tasks+1], p, q;
};

enum
{
PRIORITY_REALTIME     = REALTIME_PRIORITY_CLASS,
PRIORITY_HIGH         = HIGH_PRIORITY_CLASS,
PRIORITY_ABOVE_NORMAL = ABOVE_NORMAL_PRIORITY_CLASS,
PRIORITY_NORMAL       = NORMAL_PRIORITY_CLASS,
PRIORITY_BELOW_NORMAL = BELOW_NORMAL_PRIORITY_CLASS,
PRIORITY_BACKGROUND   = PROCESS_MODE_BACKGROUND_BEGIN,
PRIORITY_IDLE         = IDLE_PRIORITY_CLASS,
};

static inline void set_process_priority(int priority)
{
  ::SetPriorityClass(::GetCurrentProcess(), priority);
}

static inline void make_sure_process_singleton(const char* id)
{
  string mutex_name = "pe_mutex_prefix_";
  mutex_name += id;
  HANDLE hMutex = ::OpenMutex(MUTEX_ALL_ACCESS, FALSE, mutex_name.c_str());
  if (hMutex)
  {
    fprintf(stderr, "another process is running\n");
    ::CloseHandle(hMutex);
    exit(-1);
    return;
  }
  hMutex = ::CreateMutex(NULL, TRUE, mutex_name.c_str());
  if (::GetLastError() == ERROR_ALREADY_EXISTS)
  {
    fprintf(stderr, "another process is running\n");
    ::CloseHandle(hMutex);
    exit(-1);
    return;
  }
}

#endif