#ifndef __PE_NTT__
#define __PE_NTT__

#include "pe_base"
#include "pe_integer_util"
#include "pe_mod"

namespace ntt {
struct NttMod {
  // mod = r * 2 ^ k + 1
  // mod is prime
  const unsigned mod;
  const unsigned r;
  const int k;
  const unsigned g;

  unsigned omg[32];
  mutable unsigned* preOmg[32];

  NttMod(uint64 mod, uint64 r, int k, uint64 g) : mod(mod), r(r), k(k), g(g) {
    for (int i = 0; i <= k; ++i) {
      omg[i] = power_mod<uint64>(g, (mod - 1) >> i, mod);
    }
    fill(preOmg, preOmg + 32, (unsigned*)NULL);
  }

  ~NttMod() {
    for (int i = 0; i <= k; ++i) {
      if (preOmg[i] != NULL) {
        delete[] preOmg[i];
        preOmg[i] = NULL;
      }
    }
  }

  void initPreOmg(int K) const {
    PE_ASSERT(K <= k);
    for (int i = 0; i <= K; ++i) {
      if (preOmg[i] != NULL) {
        continue;
      }
      const int cnt = 1 << i;
      preOmg[i] = new unsigned[cnt];
      auto* target = preOmg[i];
      const uint64 m = omg[i];
      uint64 last = 1;
      target[0] = 1;
      for (int i = 1; i < cnt; ++i) {
        last = last * m % mod;
        target[i] = last;
      }
    }
  }
};

static const NttMod nttMod1(2013265921ull, 15ull, 27, 31ull);
static const NttMod nttMod2(2281701377ull, 17ull, 27, 3ull);
static const NttMod nttMod3(3221225473ull, 3ull, 30, 5ull);

#if PE_HAS_INT128
const uint64 M1 = 2013265921;
const uint64 M2 = 2281701377;
const uint64 M3 = 3221225473;
const uint64 M12 = M1 * M2;
const uint64 M13 = M1 * M3;
const uint64 M23 = M2 * M3;
const uint64 IM12 = 2300875347;
const uint64 IM13 = 1792765347;
const uint64 IM23 = 1006632973;

const uint128 M13M = (uint128)IM13 * M13;
const uint128 M23M = (uint128)IM23 * M23;
const uint128 M12M = (uint128)IM12 * M12;
const uint128 MMM = (uint128)M1 * M2 * M3;
#endif

template <typename T>
SL REQUIRES((is_native_integer<T>::value)) RETURN(void)
    ntt_trans(T* data, const int n) {
  int j = n >> 1;
  for (int i = 1; i < n - 1; ++i) {
    if (i < j) swap(data[i], data[j]);
    int k = n >> 1;
    while (j >= k) {
      j -= k;
      k >>= 1;
    }
    if (j < k) j += k;
  }
}

template <typename T>
SL REQUIRES((is_native_integer<T>::value)) RETURN(void)
    ntt(T* data, const int n, const NttMod& moder, bool inv = false) {
  ntt_trans(data, n);

  const auto mod = moder.mod;
  int id = 0;
  for (int h = 2; h <= n; h <<= 1) {
    const unsigned* preOmg = moder.preOmg[++id];
    if (preOmg) {
#pragma omp parallel for schedule(dynamic, 16) if (n / h > 100000)
      for (int j = 0; j < n; j += h) {
        const unsigned* omg = preOmg;
        const int halfH = h >> 1;
        const int limit = j + halfH;
        for (int k = j; k < limit; ++k) {
          const auto u = data[k] % mod;
          const auto t = (uint64)*omg++ * data[k + halfH] % mod;
          data[k] = (u + t) % mod;
          data[k + halfH] = (u + mod - t) % mod;
        }
      }
    } else {
#pragma omp parallel for schedule(dynamic, 16) if (n / h > 100000)
      for (int j = 0; j < n; j += h) {
        uint64 omgn = 1;
        const int halfH = h >> 1;
        const int limit = j + halfH;
        for (int k = j; k < limit; ++k) {
          const auto u = data[k] % mod;
          const auto t = omgn * data[k + halfH] % mod;
          data[k] = (u + t) % mod;
          data[k + halfH] = (u + mod - t) % mod;
          omgn = omgn * moder.omg[id] % mod;
        }
      }
    }
  }
  if (inv) {
    const int halfN = n >> 1;
    for (int i = 1; i < halfN; ++i) swap(data[i], data[n - i]);
    const uint64 c = power_mod<uint64>(n, mod - 2, mod);
    for (int i = 0; i < n; ++i) data[i] = c * data[i] % mod;
  }
}

void init_ntt(int k = 22) {
  PE_ASSERT(k <= 27 && k >= 0);
  nttMod1.initPreOmg(k);
  nttMod2.initPreOmg(k);
  nttMod3.initPreOmg(k);
}

// Need int128 to handle the big polynomial coefficient.
#if PE_HAS_INT128
#define HAS_POLY_MUL_NTT 1

// Multiply two polynomials.
// Make sure the length of result is at least: n + m - 1
template <typename T>
SL REQUIRES((is_native_integer<T>::value)) RETURN(void)
    poly_mul_ntt_internal(const T* X, int n, const T* Y, int m, T* result,
                          int64 mod) {
  static_assert(std::is_unsigned<T>::value, "T must be unsigned");

  int alignedSize = 1;
  while (alignedSize < n + m) alignedSize <<= 1;

  // TODO(baihacker): decide the size automatically.
  const ntt::NttMod* moderList[3] = {&ntt::nttMod1, &ntt::nttMod2, &ntt::nttMod3};
  vector<uint64> tresult[3];
#pragma omp parallel for schedule(dynamic, 1) num_threads(3)
  for (int id = 0; id < 3; ++id) {
    const ntt::NttMod& moder = *moderList[id];
    vector<uint64> XX(alignedSize);
    vector<uint64> YY(alignedSize);
    for (int i = 0; i < n; ++i) XX[i] = X[i];
    for (int i = n; i < alignedSize; ++i) XX[i] = 0;
    for (int i = 0; i < m; ++i) YY[i] = Y[i];
    for (int i = m; i < alignedSize; ++i) YY[i] = 0;
#pragma omp parallel sections if (n + m >= 100000)
    {
#pragma omp section
      ntt::ntt(&XX[0], alignedSize, moder);
#pragma omp section
      ntt::ntt(&YY[0], alignedSize, moder);
    }
    const uint64 mod = moder.mod;
    for (int i = 0; i < alignedSize; ++i) {
      XX[i] = (uint64)XX[i] * YY[i] % mod;
    }
    ntt::ntt(&XX[0], alignedSize, moder, true);
    tresult[id] = std::move(XX);
  }

  const int resultSize = n + m - 1;
#pragma omp parallel for schedule(dynamic, 100000) if (n + m >= 100000)
  for (int i = 0; i < resultSize; ++i) {
    const uint128 a = tresult[0][i] * ntt::M23M;
    const uint128 b = tresult[1][i] * ntt::M13M;
    const uint128 c = tresult[2][i] * ntt::M12M;
    const uint128 t = a + b + c;
    result[i] = t < ntt::MMM ? t % mod : t % ntt::MMM % mod;
  }
}

// Multiply two polynomials.
// The length of result is at least n + m - 1.
template <typename T>
SL REQUIRES((is_native_integer<T>::value)) RETURN(void)
    poly_mul_ntt(const T* X, const int n, const T* Y, const int m, T* result,
                 int64 mod) {
  typedef typename std::make_unsigned<T>::type unsignedT;
  poly_mul_ntt_internal<unsignedT>((const unsignedT*)X, n, (const unsignedT*)Y,
                                   m, (unsignedT*)result, mod);
}

template <typename T>
SL REQUIRES((is_native_integer<T>::value)) RETURN(vector<T>)
    poly_mul_ntt(const vector<T>& X, const vector<T>& Y, int64 mod) {
  const int n = (int)X.size() - 1;
  const int m = (int)Y.size() - 1;

  vector<T> result(n + m + 1);
  poly_mul_ntt(&X[0], n + 1, &Y[0], m + 1, &result[0], mod);

  return result;
}

#else
#define HAS_POLY_MUL_NTT 0
#endif
}  // namespace ntt

#endif
