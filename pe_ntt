#ifndef __PE_NTT__
#define __PE_NTT__

#include "pe_base"
#include "pe_integer_util"
#include "pe_mod"

namespace ntt_base {
template <typename T>
SL REQUIRES((is_native_integer<T>::value)) RETURN(void)
    ntt_trans(T* data, const int n) {
  int j = n >> 1;
  for (int i = 1; i < n - 1; ++i) {
    if (i < j) swap(data[i], data[j]);
    int k = n >> 1;
    while (j >= k) {
      j -= k;
      k >>= 1;
    }
    if (j < k) j += k;
  }
}
}  // namespace ntt_base

// mod is 32 bit
namespace ntt32 {
struct NttMod32 {
  // mod = r * 2 ^ k + 1
  // mod is prime
  const unsigned mod;
  const unsigned r;
  const int k;
  const unsigned g;

  unsigned omg[32];
  mutable unsigned* preOmg[32];

  NttMod32(unsigned mod, unsigned r, int k, unsigned g) : mod(mod), r(r), k(k), g(g) {
    for (int i = 0; i <= k; ++i) {
      omg[i] = (unsigned) power_mod<uint64>(g, (mod - 1) >> i, mod);
    }
    fill(preOmg, preOmg + 32, (unsigned*)NULL);
  }

  ~NttMod32() {
    for (int i = 0; i <= k; ++i) {
      if (preOmg[i] != NULL) {
        delete[] preOmg[i];
        preOmg[i] = NULL;
      }
    }
  }

  void initPreOmg(int K) const {
    PE_ASSERT(K <= k);
    for (int i = 0; i <= K; ++i) {
      if (preOmg[i] != NULL) {
        continue;
      }
      const int cnt = 1 << i;
      preOmg[i] = new unsigned[cnt];
      auto* target = preOmg[i];
      const uint64 m = omg[i];
      unsigned last = 1;
      target[0] = 1;
      for (int i = 1; i < cnt; ++i) {
        last = last * m % mod;
        target[i] = last;
      }
    }
  }
};

static const NttMod32 nttMod1(2013265921ull, 15ull, 27, 31ull);
static const NttMod32 nttMod2(2281701377ull, 17ull, 27, 3ull);
static const NttMod32 nttMod3(3221225473ull, 3ull, 30, 5ull);

template <typename T>
SL REQUIRES((is_native_integer<T>::value)) RETURN(void)
    ntt(T* data, const int n, const NttMod32& moder, bool inv = false) {
  ntt_base::ntt_trans(data, n);

  const auto mod = moder.mod;
  int id = 0;
  for (int h = 2; h <= n; h <<= 1) {
    const auto* preOmg = moder.preOmg[++id];
    if (preOmg) {
#if ENABLE_OPENMP
#pragma omp parallel for schedule(dynamic, 16) if (n / h > 100000)
#endif
      for (int j = 0; j < n; j += h) {
        const auto* omg = preOmg;
        const int halfH = h >> 1;
        const int limit = j + halfH;
        for (int k = j; k < limit; ++k) {
          const auto u = data[k] % mod;
          const auto t = (uint64)*omg++ * data[k + halfH] % mod;
          data[k] = (u + t) % mod;
          data[k + halfH] = (u + mod - t) % mod;
        }
      }
    } else {
#if ENABLE_OPENMP
#pragma omp parallel for schedule(dynamic, 16) if (n / h > 100000)
#endif
      for (int j = 0; j < n; j += h) {
        uint64 omgn = 1;
        const int halfH = h >> 1;
        const int limit = j + halfH;
        for (int k = j; k < limit; ++k) {
          const auto u = data[k] % mod;
          const auto t = omgn * data[k + halfH] % mod;
          data[k] = (u + t) % mod;
          data[k + halfH] = (u + mod - t) % mod;
          omgn = omgn * moder.omg[id] % mod;
        }
      }
    }
  }
  if (inv) {
    const int halfN = n >> 1;
    for (int i = 1; i < halfN; ++i) swap(data[i], data[n - i]);
    const uint64 c = power_mod<uint64>(n, mod - 2, mod);
    for (int i = 0; i < n; ++i) data[i] = c * data[i] % mod;
  }
}

void init_ntt(int k = 22) {
  PE_ASSERT(k <= 27 && k >= 0);
  nttMod1.initPreOmg(k);
  nttMod2.initPreOmg(k);
  nttMod3.initPreOmg(k);
}

// Need int128 to handle the big polynomial coefficient.
#if PE_HAS_INT128

#define HAS_POLY_MUL_NTT32 1

struct ntt_constant {
  static const uint64 M1 = 2013265921;
  static const uint64 M2 = 2281701377;
  static const uint64 M3 = 3221225473;
#if 0
  static const uint64 M12 = M1 * M2;
  static const uint64 M13 = M1 * M3;
  static const uint64 M23 = M2 * M3;
  static const uint64 IM12 = 2300875347;
  static const uint64 IM13 = 1792765347;
  static const uint64 IM23 = 1006632973;

  static const uint128 M13M = (uint128)IM13 * M13;
  static const uint128 M23M = (uint128)IM23 * M23;
  static const uint128 M12M = (uint128)IM12 * M12;
  static const uint128 MMM = (uint128)M1 * M2 * M3;
#else
  static const uint64 INV_M1__M2 = 1140850697;

  static const uint64 M1M2 = M1 * M2;
  static const uint64 INV_M3__M1M2 = 1312477593879670191ull;
#endif
};

// Multiply two polynomials.
// Make sure the length of result is at least: n + m - 1
template <typename T>
SL REQUIRES((is_native_integer<T>::value)) RETURN(void)
    poly_mul_ntt_internal(const T* X, int n, const T* Y, int m, T* result,
                          int64 mod) {
  static_assert(std::is_unsigned<T>::value, "T must be unsigned");

  int alignedSize = 1;
  while (alignedSize < n + m) alignedSize <<= 1;

  // TODO(baihacker): decide the size automatically.
  const NttMod32* moderList[3] = {&nttMod1, &nttMod2, &nttMod3};
  vector<uint64> tresult[3];
#if ENABLE_OPENMP
#pragma omp parallel for schedule(dynamic, 1) num_threads(3)
#endif
  for (int id = 0; id < 3; ++id) {
    const NttMod32& moder = *moderList[id];
    vector<uint64> XX(alignedSize);
    vector<uint64> YY(alignedSize);
    for (int i = 0; i < n; ++i) XX[i] = X[i];
    for (int i = n; i < alignedSize; ++i) XX[i] = 0;
    for (int i = 0; i < m; ++i) YY[i] = Y[i];
    for (int i = m; i < alignedSize; ++i) YY[i] = 0;
#if ENABLE_OPENMP
#pragma omp parallel sections if (n + m >= 100000)
#endif
    {
#if ENABLE_OPENMP
#pragma omp section
#endif
      ntt(&XX[0], alignedSize, moder);
#if ENABLE_OPENMP
#pragma omp section
#endif
      ntt(&YY[0], alignedSize, moder);
    }
    const uint64 mod = moder.mod;
    for (int i = 0; i < alignedSize; ++i) {
      XX[i] = (uint64)XX[i] * YY[i] % mod;
    }
    ntt(&XX[0], alignedSize, moder, true);
    tresult[id] = std::move(XX);
  }

  const int resultSize = n + m - 1;
#if ENABLE_OPENMP
#pragma omp parallel for schedule(dynamic, 100000) if (n + m >= 100000)
#endif
  for (int i = 0; i < resultSize; ++i) {
#if 0
    const uint128 a = tresult[0][i] * ntt_constant::M23M;
    const uint128 b = tresult[1][i] * ntt_constant::M13M;
    const uint128 c = tresult[2][i] * ntt_constant::M12M;
    const uint128 t = a + b + c;
    const auto tmp = t < ntt_constant::MMM ? t : t % ntt_constant::MMM;
    result[i] = mod > 0 ? tmp % mod : tmp;
#else
    const uint64 a = tresult[0][i];
    const uint64 b = tresult[1][i];
    const uint64 c = tresult[2][i];
    const uint64 x1 = b >= a ? b - a : ntt_constant::M2 - a + b;
    const uint64 y1 = x1 * ntt_constant::INV_M1__M2 % ntt_constant::M2;
    const uint64 modab = y1 * ntt_constant::M1 + a;
    const uint64 x2 = modab >= c ? modab - c : ntt_constant::M1M2 - c + modab;
    const uint64 y2 =
        (uint128)x2 * ntt_constant::INV_M3__M1M2 % ntt_constant::M1M2;
    const uint128 t = (uint128)y2 * ntt_constant::M3 + c;
    result[i] = mod > 0 ? t % mod : t;
#endif
  }
}

// Multiply two polynomials.
// The length of result is at least n + m - 1.
template <typename T>
SL REQUIRES((is_native_integer<T>::value)) RETURN(void)
    poly_mul_ntt(const T* X, const int n, const T* Y, const int m, T* result,
                 int64 mod) {
  typedef typename std::make_unsigned<T>::type unsignedT;
  poly_mul_ntt_internal<unsignedT>((const unsignedT*)X, n, (const unsignedT*)Y,
                                   m, (unsignedT*)result, mod);
}

template <typename T>
SL REQUIRES((is_native_integer<T>::value)) RETURN(vector<T>)
    poly_mul_ntt(const vector<T>& X, const vector<T>& Y, int64 mod) {
  const int n = (int)X.size() - 1;
  const int m = (int)Y.size() - 1;

  vector<T> result(n + m + 1);
  poly_mul_ntt(&X[0], n + 1, &Y[0], m + 1, &result[0], mod);

  return result;
}

#else
#define HAS_POLY_MUL_NTT32 0
#endif

#define HAS_POLY_MUL_NTT32_SMALL 1
struct ntt_small_constant {
  static const uint64 M1 = 2013265921;
  static const uint64 M2 = 2281701377;
  static const uint64 INV_M1__M2 = 1140850697;
};

// Multiply two polynomials.
// Make sure the length of result is at least: n + m - 1
template <typename T>
SL REQUIRES((is_native_integer<T>::value)) RETURN(void)
    poly_mul_ntt_small_internal(const T* X, int n, const T* Y, int m, T* result,
                                int64 mod) {
  static_assert(std::is_unsigned<T>::value, "T must be unsigned");

  int alignedSize = 1;
  while (alignedSize < n + m) alignedSize <<= 1;

  // TODO(baihacker): decide the size automatically.
  const NttMod32* moderList[2] = {&nttMod1, &nttMod2};
  vector<uint64> tresult[2];
#if ENABLE_OPENMP
#pragma omp parallel for schedule(dynamic, 1) num_threads(2)
#endif
  for (int id = 0; id < 2; ++id) {
    const NttMod32& moder = *moderList[id];
    vector<uint64> XX(alignedSize);
    vector<uint64> YY(alignedSize);
    for (int i = 0; i < n; ++i) XX[i] = X[i];
    for (int i = n; i < alignedSize; ++i) XX[i] = 0;
    for (int i = 0; i < m; ++i) YY[i] = Y[i];
    for (int i = m; i < alignedSize; ++i) YY[i] = 0;
#if ENABLE_OPENMP
#pragma omp parallel sections if (n + m >= 100000)
#endif
    {
#if ENABLE_OPENMP
#pragma omp section
#endif
      ntt(&XX[0], alignedSize, moder);
#if ENABLE_OPENMP
#pragma omp section
#endif
      ntt(&YY[0], alignedSize, moder);
    }
    const uint64 mod = moder.mod;
    for (int i = 0; i < alignedSize; ++i) {
      XX[i] = (uint64)XX[i] * YY[i] % mod;
    }
    ntt(&XX[0], alignedSize, moder, true);
    tresult[id] = std::move(XX);
  }

  const int resultSize = n + m - 1;
#if ENABLE_OPENMP
#pragma omp parallel for schedule(dynamic, 100000) if (n + m >= 100000)
#endif
  for (int i = 0; i < resultSize; ++i) {
    const uint64 a = tresult[0][i];
    const uint64 b = tresult[1][i];
    const uint64 c = b >= a ? b - a : b + ntt_small_constant::M2 - a;
    const uint64 d =
        c * ntt_small_constant::INV_M1__M2 % ntt_small_constant::M2;
    const uint64 t = d * ntt_small_constant::M1 + a;
    result[i] = mod > 0 ? t % mod : t;
  }
}

// Multiply two polynomials.
// The length of result is at least n + m - 1.
template <typename T>
SL REQUIRES((is_native_integer<T>::value)) RETURN(void)
    poly_mul_ntt_small(const T* X, const int n, const T* Y, const int m,
                       T* result, int64 mod) {
  typedef typename std::make_unsigned<T>::type unsignedT;
  poly_mul_ntt_small_internal<unsignedT>(
      (const unsignedT*)X, n, (const unsignedT*)Y, m, (unsignedT*)result, mod);
}

template <typename T>
SL REQUIRES((is_native_integer<T>::value)) RETURN(vector<T>)
    poly_mul_ntt_small(const vector<T>& X, const vector<T>& Y, int64 mod) {
  const int n = (int)X.size() - 1;
  const int m = (int)Y.size() - 1;

  vector<T> result(n + m + 1);
  poly_mul_ntt_small(&X[0], n + 1, &Y[0], m + 1, &result[0], mod);

  return result;
}
}  // namespace ntt32

#if PE_HAS_INT128
#define HAS_POLY_MUL_NTT64 1
#define HAS_POLY_MUL_NTT64_SMALL 0

// mod is 64 bit
namespace ntt64 {
struct NttMod64 {
  // mod = r * 2 ^ k + 1
  // mod is prime
  const uint64 mod;
  const unsigned r;
  const int k;
  const unsigned g;

  uint64 omg[32];
  mutable uint64* preOmg[32];

  NttMod64(uint64 mod, uint64 r, int k, uint64 g) : mod(mod), r(r), k(k), g(g) {
    for (int i = 0; i <= k; ++i) {
      omg[i] = power_mod_ex<uint64>(g, (mod - 1) >> i, mod);
    }
    fill(preOmg, preOmg + 32, (uint64*)NULL);
  }

  ~NttMod64() {
    for (int i = 0; i <= k; ++i) {
      if (preOmg[i] != NULL) {
        delete[] preOmg[i];
        preOmg[i] = NULL;
      }
    }
  }

  void initPreOmg(int K) const {
    PE_ASSERT(K <= k);
    for (int i = 0; i <= K; ++i) {
      if (preOmg[i] != NULL) {
        continue;
      }
      const int cnt = 1 << i;
      preOmg[i] = new uint64[cnt];
      auto* target = preOmg[i];
      const uint64 m = omg[i];
      uint64 last = 1;
      target[0] = 1;
      for (int i = 1; i < cnt; ++i) {
        last = mod128_64((uint128)last * m, mod);
        target[i] = last;
      }
    }
  }
};

static const NttMod64 nttMod1(180143985094819841ull, 5ull, 55, 6ull);
static const NttMod64 nttMod2(1945555039024054273ull, 27ull, 56, 5ull);

template <typename T>
SL REQUIRES((is_native_integer<T>::value)) RETURN(void)
    ntt(T* data, const int n, const NttMod64& moder, bool inv = false) {
  ntt_base::ntt_trans(data, n);

  const auto mod = moder.mod;
  int id = 0;
  for (int h = 2; h <= n; h <<= 1) {
    const auto* preOmg = moder.preOmg[++id];
    if (preOmg) {
#if ENABLE_OPENMP
#pragma omp parallel for schedule(dynamic, 16) if (n / h > 100000)
#endif
      for (int j = 0; j < n; j += h) {
        const auto* omg = preOmg;
        const int halfH = h >> 1;
        const int limit = j + halfH;
        for (int k = j; k < limit; ++k) {
          const auto u = data[k] % mod;
          const auto t = mod128_64((uint128)*omg++ * data[k + halfH], mod);
          data[k] = (u + t) % mod;
          data[k + halfH] = (u + mod - t) % mod;
        }
      }
    } else {
#if ENABLE_OPENMP
#pragma omp parallel for schedule(dynamic, 16) if (n / h > 100000)
#endif
      for (int j = 0; j < n; j += h) {
        uint64 omgn = 1;
        const int halfH = h >> 1;
        const int limit = j + halfH;
        for (int k = j; k < limit; ++k) {
          const auto u = data[k] % mod;
          const auto t = mod128_64((uint128)omgn * data[k + halfH], mod);
          data[k] = (u + t) % mod;
          data[k + halfH] = (u + mod - t) % mod;
          omgn = mod128_64((uint128)omgn * moder.omg[id], mod);
        }
      }
    }
  }
  if (inv) {
    const int halfN = n >> 1;
    for (int i = 1; i < halfN; ++i) swap(data[i], data[n - i]);
    const uint64 c = power_mod_ex<uint64>(n, mod - 2, mod);
    for (int i = 0; i < n; ++i) data[i] = mod128_64((uint128)c * data[i], mod);
  }
}

void init_ntt(int k = 22) {
  PE_ASSERT(k <= 30 && k >= 0);
  nttMod1.initPreOmg(k);
  nttMod2.initPreOmg(k);
}

struct ntt_constant {
  static const uint64 M1 = 180143985094819841ull;
  static const uint64 M2 = 1945555039024054273ull;
  static const uint64 INV_M1__M2 = 714693687804754632ull;
};

// Multiply two polynomials.
// Make sure the length of result is at least: n + m - 1
template <typename T>
SL REQUIRES((is_native_integer<T>::value)) RETURN(void)
    poly_mul_ntt_internal(const T* X, int n, const T* Y, int m, T* result,
                          int64 mod) {
  static_assert(std::is_unsigned<T>::value, "T must be unsigned");

  int alignedSize = 1;
  while (alignedSize < n + m) alignedSize <<= 1;

  // TODO(baihacker): decide the size automatically.
  const NttMod64* moderList[2] = {&nttMod1, &nttMod2};
  vector<uint64> tresult[2];
#if ENABLE_OPENMP
#pragma omp parallel for schedule(dynamic, 1) num_threads(3)
#endif
  for (int id = 0; id < 2; ++id) {
    const NttMod64& moder = *moderList[id];
    vector<uint64> XX(alignedSize);
    vector<uint64> YY(alignedSize);
    for (int i = 0; i < n; ++i) XX[i] = X[i];
    for (int i = n; i < alignedSize; ++i) XX[i] = 0;
    for (int i = 0; i < m; ++i) YY[i] = Y[i];
    for (int i = m; i < alignedSize; ++i) YY[i] = 0;
#if ENABLE_OPENMP
#pragma omp parallel sections if (n + m >= 100000)
#endif
    {
#if ENABLE_OPENMP
#pragma omp section
#endif
      ntt(&XX[0], alignedSize, moder);
#if ENABLE_OPENMP
#pragma omp section
#endif
      ntt(&YY[0], alignedSize, moder);
    }
    const uint64 mod = moder.mod;
    for (int i = 0; i < alignedSize; ++i) {
      XX[i] = mod128_64((uint128)XX[i] * YY[i], mod);
    }
    ntt(&XX[0], alignedSize, moder, true);
    tresult[id] = std::move(XX);
  }

  const int resultSize = n + m - 1;
#if ENABLE_OPENMP
#pragma omp parallel for schedule(dynamic, 100000) if (n + m >= 100000)
#endif
  for (int i = 0; i < resultSize; ++i) {
    const uint64 a = tresult[0][i];
    const uint64 b = tresult[1][i];
    const uint64 x = b >= a ? b - a : b + ntt_constant::M2 - a;
    const uint64 y =
        mod128_64((uint128)x * ntt_constant::INV_M1__M2, ntt_constant::M2);
    const uint128 t = (uint128)y * ntt_constant::M1 + a;
    result[i] = mod > 0 ? t % mod : t;
  }
}

// Multiply two polynomials.
// The length of result is at least n + m - 1.
template <typename T>
SL REQUIRES((is_native_integer<T>::value)) RETURN(void)
    poly_mul_ntt(const T* X, const int n, const T* Y, const int m, T* result,
                 int64 mod) {
  typedef typename std::make_unsigned<T>::type unsignedT;
  poly_mul_ntt_internal<unsignedT>((const unsignedT*)X, n, (const unsignedT*)Y,
                                   m, (unsignedT*)result, mod);
}

template <typename T>
SL REQUIRES((is_native_integer<T>::value)) RETURN(vector<T>)
    poly_mul_ntt(const vector<T>& X, const vector<T>& Y, int64 mod) {
  const int n = (int)X.size() - 1;
  const int m = (int)Y.size() - 1;

  vector<T> result(n + m + 1);
  poly_mul_ntt(&X[0], n + 1, &Y[0], m + 1, &result[0], mod);

  return result;
}

#define HAS_POLY_MUL_NTT64_SMALL 1
// Multiply two polynomials.
// Make sure the length of result is at least: n + m - 1
template <typename T>
SL REQUIRES((is_native_integer<T>::value)) RETURN(void)
    poly_mul_ntt_small_internal(const T* X, int n, const T* Y, int m, T* result,
                                int64 mod) {
  static_assert(std::is_unsigned<T>::value, "T must be unsigned");

  int alignedSize = 1;
  while (alignedSize < n + m) alignedSize <<= 1;

  // TODO(baihacker): decide the size automatically.
  const NttMod64* moderList[1] = {&nttMod2};
  vector<uint64> tresult[1];
  for (int id = 0; id < 1; ++id) {
    const NttMod64& moder = *moderList[id];
    vector<uint64> XX(alignedSize);
    vector<uint64> YY(alignedSize);
    for (int i = 0; i < n; ++i) XX[i] = X[i];
    for (int i = n; i < alignedSize; ++i) XX[i] = 0;
    for (int i = 0; i < m; ++i) YY[i] = Y[i];
    for (int i = m; i < alignedSize; ++i) YY[i] = 0;
#if ENABLE_OPENMP
#pragma omp parallel sections if (n + m >= 100000)
#endif
    {
#if ENABLE_OPENMP
#pragma omp section
#endif
      ntt(&XX[0], alignedSize, moder);
#if ENABLE_OPENMP
#pragma omp section
#endif
      ntt(&YY[0], alignedSize, moder);
    }
    const uint64 mod = moder.mod;
    for (int i = 0; i < alignedSize; ++i) {
      XX[i] = mod128_64((uint128)XX[i] * YY[i], mod);
    }
    ntt(&XX[0], alignedSize, moder, true);
    tresult[id] = std::move(XX);
  }

  const int resultSize = n + m - 1;
#if ENABLE_OPENMP
#pragma omp parallel for schedule(dynamic, 100000) if (n + m >= 100000)
#endif
  for (int i = 0; i < resultSize; ++i) {
    const uint64 a = tresult[0][i];
    result[i] = mod > 0 ? a % mod : a;
  }
}

// Multiply two polynomials.
// The length of result is at least n + m - 1.
template <typename T>
SL REQUIRES((is_native_integer<T>::value)) RETURN(void)
    poly_mul_ntt_small(const T* X, const int n, const T* Y, const int m,
                       T* result, int64 mod) {
  typedef typename std::make_unsigned<T>::type unsignedT;
  poly_mul_ntt_small_internal<unsignedT>(
      (const unsignedT*)X, n, (const unsignedT*)Y, m, (unsignedT*)result, mod);
}

template <typename T>
SL REQUIRES((is_native_integer<T>::value)) RETURN(vector<T>)
    poly_mul_ntt_small(const vector<T>& X, const vector<T>& Y, int64 mod) {
  const int n = (int)X.size() - 1;
  const int m = (int)Y.size() - 1;

  vector<T> result(n + m + 1);
  poly_mul_ntt_small(&X[0], n + 1, &Y[0], m + 1, &result[0], mod);

  return result;
}
}  // namespace ntt64
#else
#define HAS_POLY_MUL_NTT64 1
#define HAS_POLY_MUL_NTT64_SMALL 0
#endif

#include "pe_ntt_min_25"

#if ENABLE_LIBBF
#include "pe_ntt_libbf"
#endif

#if PE_HAS_INT128
#if !HAS_POLY_MUL_NTT32_SMALL
#error "HAS_POLY_MUL_NTT32_SMALL must be true if PE_HAS_INT128 is true"
#endif

#if !HAS_POLY_MUL_NTT32
#error "HAS_POLY_MUL_NTT32 must be true if PE_HAS_INT128 is true"
#endif

#if !HAS_POLY_MUL_NTT64_SMALL
#error "HAS_POLY_MUL_NTT64_SMALL must be true if PE_HAS_INT128 is true"
#endif

#if !HAS_POLY_MUL_NTT64
#error "HAS_POLY_MUL_NTT64 must be true if PE_HAS_INT128 is true"
#endif

#if defined(__PE_NTT_MIN_25__)

#if !HAS_POLY_MUL_MIN25_NTT
#error "HAS_POLY_MUL_MIN25_NTT must be true if PE_HAS_INT128 is true"
#endif

#if !HAS_POLY_MUL_MIN25_NTT_SMALL
#error "HAS_POLY_MUL_MIN25_NTT_SMALL must be true if PE_HAS_INT128 is true"
#endif

#endif

#endif

/**
 * ntt32 small
 * (p-1)^2*n < 4593671624212873217                              4.5e18
 *
 * ntt32 large
 * (p-1)^2*n < 14797252050511790781119856641                    1.4e28
 *
 * ntt64 small
 * (p-1)^2*n < 1945555039024054273                              1.9e18
 *
 * ntt64 large
 * (p-1)^2*n < 350480037951100867051507526341230593             3.5e35
 *
 * min25 ntt small
 * (p-1)^2*n < 1128298388379402241                              1.1e18
 *
 * min25 ntt large
 * (p-1)^2*n < 1265198875113262859862934516672757761            1.2e36
 *
 * libbf
 * (p-1)^2*n < 340282366920938463463374607431768211456 (2^128)  3.4e38
 */
#endif
