#ifndef __PE_NTT__
#define __PE_NTT__

#include "pe_base"
#include "pe_integer_util"
#include "pe_mod"

namespace ntt {
struct NttMod {
  // mod = r * 2 ^ k + 1
  // mod is prime
  const uint64 mod;
  const uint64 r;
  const int k;
  const uint64 g;

  uint64 omg[32];
  NttMod(uint64 mod, uint64 r, int k, uint64 g)
    : mod(mod), r(r), k(k), g(g) {
    for (int i = 0; i <= k; ++i) {
      omg[i] = power_mod(g, (mod - 1) >> i, mod);
    }
  }
};

static const NttMod nttMod1(2013265921ull, 15ull, 27, 31ull);
static const NttMod nttMod2(2281701377ull, 17ull, 27, 3ull);
static const NttMod nttMod3(3221225473ull, 3ull, 30, 5ull);

const uint64 M1 = 2013265921;
const uint64 M2 = 2281701377;
const uint64 M3 = 3221225473;
const uint64 M12 = M1 * M2;
const uint64 M13 = M1 * M3;
const uint64 M23 = M2 * M3;
const uint64 IM12 = 2300875347;
const uint64 IM13 = 1792765347;
const uint64 IM23 = 1006632973;

uint128 M13M = (uint128)IM13 * M13;
uint128 M23M = (uint128)IM23 * M23;
uint128 M12M = (uint128)IM12 * M12;
uint128 MMM = (uint128)M1 * M2 * M3;

template<typename T>
SL
REQUIRES((is_native_integer<T>::value))
RETURN(void)
ntt_trans(T* data, const int n) {
  int j = n >> 1;
  for (int i = 1; i < n - 1; ++i) {
    if (i < j) swap(data[i], data[j]);
    int k = n >> 1;
    while (j >= k) {
      j -= k;
      k >>= 1;
    }
    if (j < k) j += k;
  }
}

template<typename T>
SL
REQUIRES((is_native_integer<T>::value))
RETURN(void)
ntt(T* data, const int n, const NttMod& moder, bool inv = false) {
  ntt_trans(data, n);

  const auto mod = moder.mod;
  int id = 0;
  for (int h = 2; h <= n; h <<= 1) {
    ++id;
    #pragma omp parallel for schedule(dynamic, 16) if (n / h > 100000)
    for (int j = 0; j < n; j += h) {
      uint64 omgn = 1;
      const int halfH = h >> 1;
      const int limit = j + halfH;
      for (int k = j; k < limit; ++k) {
        const auto u = data[k] % mod;
        const auto t = omgn * data[k + halfH] % mod;
        data[k] = (u + t) % mod;
        data[k+halfH] = (u + mod - t) % mod;
        omgn = omgn * moder.omg[id] % mod;
      }
    }
  }
  if (inv) {
    const int halfN = n >> 1;
    for (int i = 1; i < halfN; ++i)
      swap(data[i], data[n - i]);
    const uint64 c = power_mod<uint64>(n, mod - 2, mod);
    for (int i = 0; i < n; ++i)
      data[i] = c * data[i] % mod;
  }
}

// Need int128 to handle the big polynomial coefficient.
#if PE_HAS_INT128
#define HAS_POLY_MUL_NTT 1

// Multiply two polynomials.
// Make sure the length of result is at least: n + m - 1
template <typename T>
SL REQUIRES((is_native_integer<T>::value)) RETURN(void)
    poly_mul_ntt_internal(const T* X, int n, const T* Y, int m, T* result,
                          int64 mod) {
  static_assert(std::is_unsigned<T>::value, "T must be unsigned");

  int alignedSize = 1;
  while (alignedSize < n + m) alignedSize <<= 1;

  // TODO(baihacker): decide the size automatically.
  ntt::NttMod moder[3] = {ntt::nttMod1, ntt::nttMod2, ntt::nttMod3};
  vector<uint64> tresult[3];
#pragma omp parallel for schedule(dynamic, 1) num_threads(3)
  for (int id = 0; id < 3; ++id) {
    vector<uint64> XX(alignedSize);
    vector<uint64> YY(alignedSize);
    for (int i = 0; i < n; ++i) XX[i] = X[i];
    for (int i = n; i < alignedSize; ++i) XX[i] = 0;
    for (int i = 0; i < m; ++i) YY[i] = Y[i];
    for (int i = m; i < alignedSize; ++i) YY[i] = 0;
#pragma omp parallel sections if (n + m >= 100000)
    {
#pragma omp section
      ntt::ntt(&XX[0], alignedSize, moder[id]);
#pragma omp section
      ntt::ntt(&YY[0], alignedSize, moder[id]);
    }
    const uint64 mod = moder[id].mod;
    for (int i = 0; i < alignedSize; ++i) {
      XX[i] = (uint64)XX[i] * YY[i] % mod;
    }
    ntt::ntt(&XX[0], alignedSize, moder[id], true);
    tresult[id] = std::move(XX);
  }

  const int resultSize = n + m - 1;
#pragma omp parallel for schedule(dynamic, 100000) if (n + m >= 100000)
  for (int i = 0; i < resultSize; ++i) {
    const uint128 a = tresult[0][i] * ntt::M23M;
    const uint128 b = tresult[1][i] * ntt::M13M;
    const uint128 c = tresult[2][i] * ntt::M12M;
    const uint128 t = a + b + c;
    result[i] = t < ntt::MMM ? t % mod : t % ntt::MMM % mod;
  }
}

// Multiply two polynomials.
// The length of result is at least n + m - 1.
template <typename T>
SL REQUIRES((is_native_integer<T>::value)) RETURN(void)
    poly_mul_ntt(const T* X, const int n, const T* Y, const int m, T* result,
                 int64 mod) {
  typedef typename std::make_unsigned<T>::type unsignedT;
  poly_mul_ntt_internal<unsignedT>((const unsignedT*)X, n, (const unsignedT*)Y,
                                   m, (unsignedT*)result, mod);
}

template <typename T>
SL REQUIRES((is_native_integer<T>::value)) RETURN(vector<T>)
    poly_mul_ntt(const vector<T>& X, const vector<T>& Y, int64 mod) {
  const int n = (int)X.size() - 1;
  const int m = (int)Y.size() - 1;

  vector<T> result(n + m + 1);
  poly_mul_ntt(&X[0], n + 1, &Y[0], m + 1, &result[0], mod);

  return result;
}

#else
#define HAS_POLY_MUL_NTT 0
#endif
}

#endif