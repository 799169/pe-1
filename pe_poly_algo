#ifndef __PE_POLY_ALGO__
#define __PE_POLY_ALGO__

#include "pe_base"
#include "pe_int128"
#include "pe_mod"
#include "pe_ntt"
#include "pe_poly"
#include "pe_type_traits"

struct PSPTree {
  int64 mod;

  int64* v;
  int n;

  vector<int64> p;

  PSPTree* L;
  PSPTree* R;

  ~PSPTree() {
    if (L) delete L;
    if (R) delete R;
  }

  static PSPTree* build_minus(int64* values, int n, int64 mod) {
    auto* ptree = new PSPTree();
    auto& tree = *ptree;
    tree.mod = mod;
    tree.v = values;
    tree.n = n;
    tree.L = tree.R = NULL;
    if (n == 1) {
      // -x0 + x
      int64 t = values[0];
      tree.p.emplace_back(t == 0 ? 0 : mod - t);
      tree.p.emplace_back(1 % mod);
      return ptree;
    }
    int c1 = n >> 1, c2 = n - c1;
    tree.L = build_minus(values, c1, mod);
    tree.R = build_minus(values + c1, c2, mod);
    tree.p = poly_mul(tree.L->p, tree.R->p, mod);
    return ptree;
  }

  static PSPTree* build_plus(int64* values, int n, int64 mod) {
    auto* ptree = new PSPTree();
    auto& tree = *ptree;
    tree.mod = mod;
    tree.v = values;
    tree.n = n;
    tree.L = tree.R = NULL;
    if (n == 1) {
      // x0 + x
      int64 t = values[0];
      tree.p.emplace_back(t);
      tree.p.emplace_back(1);
      return ptree;
    }
    int c1 = n >> 1, c2 = n - c1;
    tree.L = build_plus(values, c1, mod);
    tree.R = build_plus(values + c1, c2, mod);
    tree.p = poly_mul(tree.L->p, tree.R->p, mod);
    return ptree;
  }
};

// size(V) = n
template <typename T>
SL REQUIRES((is_native_integer<T>::value)) RETURN(void)
    poly_evaluate_mod_normal_internal(const T* X, int n, PSPTree* psp,
                                      T* result, int64 mod) {
  if (psp->n == 1) {
    result[0] = (X[0] + psp->v[0] * X[1]) % mod;
    return;
  }
  int c1 = psp->n >> 1;
  int c2 = psp->n - c1;

  vector<T> m(max(psp->L->p.size(), psp->R->p.size()));
  poly_mod(X, n, (const T*)&psp->L->p[0], static_cast<int>(psp->L->p.size()),
           &m[0], mod);
  poly_evaluate_mod_normal_internal(
      &m[0], static_cast<int>(psp->L->p.size()) - 1, psp->L, result, mod);
  poly_mod(X, n, (const T*)&psp->R->p[0], static_cast<int>(psp->R->p.size()),
           &m[0], mod);
  poly_evaluate_mod_normal_internal(
      &m[0], static_cast<int>(psp->R->p.size()) - 1, psp->R, result + c1, mod);
}

// size(V) = n
template <typename T>
SL REQUIRES((is_native_integer<T>::value)) RETURN(void)
    poly_evaluate_mod_normal_internal(const T* X, int n, const T* V, T* result,
                                      int64 mod) {
  static_assert(std::is_unsigned<T>::value, "T must be unsigned");
  PSPTree* psp = PSPTree::build_minus((int64*)V, n, mod);
  poly_evaluate_mod_normal_internal(X, n, psp, result, mod);
  delete psp;
}

// Tellegen's Principle into Pratice
// A. Bostan, G. Lecerf, E. Schost
// size(V) = n
template <typename T>
SL REQUIRES((is_native_integer<T>::value)) RETURN(void)
    poly_evaluate_mod_bls_internal(const T* X, int n, const T* V, T* result,
                                   int64 mod) {
  static_assert(std::is_unsigned<T>::value, "T must be unsigned");
  vector<vector<vector<T>>> tree;
  {
    vector<vector<T>> from;
    for (int i = 0; i < n; ++i) {
      vector<T> tmp{(V[i] == 0 ? 0 : mod - V[i]) % mod, 1};
      from.push_back(tmp);
    }

    tree.push_back(from);
    int lastSize = n;
    while (lastSize != 1) {
      vector<vector<T>> to;
      to.reserve(lastSize / 2);
      for (int i = 0; i < lastSize / 2; ++i) {
        to.push_back(poly_mul(from[i * 2], from[i * 2 + 1], mod));
      }
      if (lastSize & 1) {
        to.push_back(from[lastSize - 1]);
      }
      lastSize = (lastSize + 1) >> 1;
      from.swap(to);
      tree.push_back(from);
    }
  }

  const int d = (int)tree.size() - 1;
  {
    auto alpha = tree[d][0];
    reverse(alpha.begin(), alpha.end());
    alpha = poly_inv_mod(alpha, n, mod);
    reverse(alpha.begin(), alpha.end());

    vector<uint64> b(X, X + n);
    int degb = sz(b) - 1;
    auto t = poly_mul(alpha, b, mod);
    assert(sz(t) - 1 == n - 1 + degb);
    for (int i = n - 1, j = 0; i <= (n - 1) + degb; ++i, ++j) {
      t[j] = t[i];
    }
    assert(degb + 1 >= n);
    t.resize(n);
    reverse(t.begin(), t.end());

    vector<vector<T>> c(n);
    c[0] = std::move(t);
    // c[0] = vector<uint64>(X, X+n);
    for (int i = d; i > 0; --i) {
      int hi = (int)tree[i].size();
      for (int j = hi - 1; j >= 0; --j) {
        int u = j * 2;
        int v = u + 1;
        if (v >= tree[i - 1].size()) {
          c[u] = c[j];
          continue;
        }
        int nn = (int)tree[i][j].size() - 1;
        vector<T> x;
        {
          const int os = sz(tree[i - 1][2 * j]);
          reverse(tree[i - 1][2 * j].begin(), tree[i - 1][2 * j].end());
          x = poly_mul(tree[i - 1][2 * j], c[j], mod);
          int s = 0;
          for (int i = os - 1, j = 0; i < x.size() && j < nn; ++i, ++j) {
            x[j] = x[i];
            ++s;
          }
          x.resize(s);
        }
        vector<T> y;
        {
          const int os = sz(tree[i - 1][2 * j + 1]);
          reverse(tree[i - 1][2 * j + 1].begin(), tree[i - 1][2 * j + 1].end());
          y = poly_mul(tree[i - 1][2 * j + 1], c[j], mod);
          int s = 0;
          for (int i = os - 1, j = 0; i < y.size() && j < nn; ++i, ++j) {
            y[j] = y[i];
            ++s;
          }
          y.resize(s);
        }
        c[2 * j + 1] = std::move(x);
        c[2 * j] = std::move(y);
      }
    }
    for (int i = 0; i < n; ++i) result[i] = c[i][0];
  }
}

// size(V) = n
template <typename T>
SL REQUIRES((is_native_integer<T>::value)) RETURN(void)
    poly_evaluate_mod_normal(const T* X, const int n, const T* V, T* result,
                             int64 mod) {
  typedef typename std::make_unsigned<T>::type unsignedT;
  poly_evaluate_mod_normal_internal<unsignedT>(
      (const unsignedT*)X, n, (const unsignedT*)V, (unsignedT*)result, mod);
}

// size x = size v
template <typename T>
SL REQUIRES((is_native_integer<T>::value)) RETURN(vector<T>)
    poly_evaluate_mod_normal(const vector<T>& X, const vector<T>& V,
                             int64 mod) {
  const int n = (int)X.size();
  vector<T> result(n);
  poly_evaluate_mod_normal(&X[0], n, &V[0], &result[0], mod);
  return result;
}

// size x = size v
SL vector<int64> poly_evaluate_mod_normal(const NModPoly& X,
                                          const vector<int64>& V) {
  return poly_evaluate_mod_normal(X.data, V, X.mod);
}

// size(V) = n
template <typename T>
SL REQUIRES((is_native_integer<T>::value)) RETURN(void)
    poly_evaluate_mod_bls(const T* X, const int n, const T* V, T* result,
                          int64 mod) {
  typedef typename std::make_unsigned<T>::type unsignedT;
  poly_evaluate_mod_bls_internal<unsignedT>(
      (const unsignedT*)X, n, (const unsignedT*)V, (unsignedT*)result, mod);
}

// size x = size v
template <typename T>
SL REQUIRES((is_native_integer<T>::value)) RETURN(vector<T>)
    poly_evaluate_mod_bls(const vector<T>& X, const vector<T>& V, int64 mod) {
  const int n = (int)X.size();
  vector<T> result(n);
  poly_evaluate_mod_bls(&X[0], n, &V[0], &result[0], mod);
  return result;
}

// size x = size v
SL vector<int64> poly_evaluate_mod_bls(const NModPoly& X,
                                       const vector<int64>& V) {
  return poly_evaluate_mod_bls(X.data, V, X.mod);
}

// Known f[0],f[1],f[2],...,f[d]
// Calcupate f[0+offset],f[1+offset],f[2+offset],...,f[d+offset]
// offset > d
template <typename T>
SL REQUIRES((is_native_integer<T>::value)) RETURN(void)
    poly_offset_evaluate_internal(int d, const T* h, T* result, int64 offset,
                                  const T* preFactInv, T mod) {
  static_assert(std::is_unsigned<T>::value, "T must be unsigned");

  vector<T> A(d + 1);
  vector<T> B(2 * d + 1);
  vector<T> C(3 * d + 1);
  vector<T> T0(2 * d + 2);
  vector<T> T1(2 * d + 2);
  for (int i = 0; i <= d; ++i) {
    auto t = mul_mod_ex(h[i], preFactInv[i], mod);
    t = mul_mod_ex(t, preFactInv[d - i], mod);
    if ((d - i) & 1) {
      A[i] = t == 0 ? 0 : mod - t;
    } else {
      A[i] = t;
    }
  }

  T0[0] = T1[0] = 1;
  for (int i = -d, j = 1; i <= d; ++i, ++j) {
    T0[j] = mul_mod_ex(T0[j - 1], offset + i, mod);
  }

  T1[2 * d + 1] = power_mod_ex(T0[2 * d + 1], mod - 2, mod);
  for (int i = d - 1, j = 2 * d; i >= -d; --i, --j) {
    T1[j] = mul_mod_ex(T1[j + 1], offset + i + 1, mod);
  }

  for (int i = -d, j = 1; i <= d; ++i, ++j) {
    B[j - 1] = mul_mod_ex(T1[j], T0[j - 1], mod);
  }

  poly_mul(&A[0], d + 1, &B[0], 2 * d + 1, &C[0], mod);
  copy(&C[0] + d, &C[0] + 2 * d + 1, result);

  for (int i = 0, j = d + 1; i <= d; ++i, ++j) {
    result[i] = mul_mod_ex(result[i], T0[j], mod);
    result[i] = mul_mod_ex(result[i], T1[j - d - 1], mod);
  }
}

template <typename T>
SL REQUIRES((is_native_integer<T>::value)) RETURN(void)
    poly_offset_evaluate(int d, const T* h, T* result, int64 offset,
                         const T* preFactInv, T mod) {
  typedef typename std::make_unsigned<T>::type unsignedT;
  poly_offset_evaluate_internal<unsignedT>(
      d, (const unsignedT*)h, (unsignedT*)result, offset, preFactInv, mod);
}

template <typename T>
SL REQUIRES((is_native_integer<T>::value)) RETURN(vector<T>)
    poly_offset_evaluate(const vector<T>& values, int64 offset,
                         const T* preFactInv, T mod) {
  const int d = (int)values.size() - 1;
  vector<T> result(d + 1);
  poly_offset_evaluate(d, &values[0], &result[0], offset, preFactInv, mod);
  return std::move(result);
}

// Compuate n! % p
// Algorithm source: // https://min-25.hatenablog.com/entry/2017/04/10/215046
// Complexity is M(p^(1/2))
struct FactModer {
  FactModer(uint64 p) : p(p) { init(); }

  // Evaluate (x+v*0+1)*(x+v*1+1)*(x+v*2+1)*...*(x+v*(d-1)+1) at 0, 1, 2, ..., d
  void evaluate(int d, uint64* result, uint64 v) {
    if (d == 1) {
      result[0] = 1;
      result[1] = p == 2 ? 0 : 2;
      return;
    }

    const int halfD = d >> 1;
    evaluate(halfD, result, v);
    copy(result, result + halfD + 1, &G0[0]);
#if ENABLE_OPENMP
#pragma omp parallel sections if (d >= 10000)
#endif
    {
#if ENABLE_OPENMP
#pragma omp section
#endif
      poly_offset_evaluate<uint64>(halfD, result, &G1[0], halfD + 1,
                                   &preFactInv[0], p);
#if ENABLE_OPENMP
#pragma omp section
#endif
      poly_offset_evaluate<uint64>(halfD, result, &G2[0], v * halfD,
                                   &preFactInv[0], p);
#if ENABLE_OPENMP
#pragma omp section
#endif
      poly_offset_evaluate<uint64>(halfD, result, &G3[0], v * halfD + halfD,
                                   &preFactInv[0], p);
    }

    for (int i = 0; i <= halfD; ++i) {
      result[i] = mul_mod_ex(G0[i], G2[i], p);
    }
    for (int i = halfD + 1, j = 0; i <= halfD * 2; ++i, ++j) {
      result[i] = mul_mod_ex(G1[j], G3[j + 1], p);
    }

    if (d & 1) {
      uint64 tmp = (v * (d - 1) + 1) % p;
      for (int i = 0; i <= 2 * halfD; ++i) {
        result[i] = mul_mod_ex(result[i], tmp++, p);
        if (tmp >= p) tmp -= p;
      }
      uint64 t = 1;
      uint64 c = d + 1;
      for (int i = 0; i < d; ++i) {
        t = mul_mod_ex(t, c, p);
        c += v;
        if (c >= p) c -= p;
      }
      result[d] = t;
    }
  }

  int64 cal(uint64 n) {
    if (n >= p) return 0;
    if (n < q) return preFact[n];

    uint64 m = static_cast<int64>(sqrt(n));
    uint64 ret = 1;

    for (uint64 i = m * m + 1; i <= n; ++i) {
      ret = mul_mod_ex(ret, i, p);
    }

    evaluate(static_cast<int>(m), static_cast<uint64*>(&V[0]), m);

    for (int i = 0; i < m; ++i) {
      ret = mul_mod_ex(ret, V[i], p);
    }
    return static_cast<int64>(ret);
  }

  void init() {
    q = static_cast<uint64>(sqrt(p));
    while (q * q < p) ++q;
    q <<= 1;
    q += 1;
    preFact.resize(q);
    preFactInv.resize(q);
    init_seq_prod<uint64>(&preFact[0], 1, q - 1, p);
    init_seq_prod_inv<uint64>(&preFactInv[0], 1, q - 1, p,
                              power_mod_ex<uint64>(preFact[q - 1], p - 2, p));
    G0.resize(q);
    G1.resize(q);
    G2.resize(q);
    G3.resize(q);
    V.resize(q);
  }

  vector<uint64> preFact, preFactInv;
  vector<uint64> G0, G1, G2, G3;
  vector<uint64> V;
  uint64 p;
  uint64 q;
};

#if 0
// Y = X
// s(i) = (Y[1]*x+Y[0])(Y[3]x+Y[2])...(Y[2i+1]x+Y[2i])
// return s(n-1)
// size s(n-1) = n + 1
template <typename T>
SL REQUIRES((is_native_integer<T>::value)) RETURN(void)
    poly_batch_mul_mod_internal(const T* X, int n, T* result,
                                   int64 mod) {
  static_assert(std::is_unsigned<T>::value, "T must be unsigned");
  vector<vector<T>> from;
  for (int i = 0; i < n; ++i) {
    vector<T> tmp{X[2*i] % mod, X[2*i+1]%mod};
    from.push_back(tmp);
  }
  int lastSize = n;
  while (lastSize != 1) {
    vector<vector<T>> to;
    for (int i = 0; i < lastSize / 2; ++i) {
      to.push_back(poly_mul(from[i * 2], from[i * 2 + 1], mod));
    }
    if (lastSize & 1) {
      to.push_back(from[lastSize - 1]);
    }
    lastSize = lastSize + 1 >> 1;
    from.swap(to);
  }
  auto& t = from[0];
  PE_ASSERT(sz(t) == n + 1);
  copy(t.begin(), t.end(), result);
}

// n = e - s
// Y = X[2s:2e]
// s(i) = (Y[1]*x+Y[0])(Y[3]x+Y[2])...(Y[2i+1]x+Y[2i])
// return s(n-1)
// size s(n-1) = n + 1
template <typename T>
SL REQUIRES((is_native_integer<T>::value)) RETURN(void)
    poly_batch_mul_mod_internal(const T* X, int s, int e, T* result,
                                   int64 mod) {
  poly_batch_mul_mod_internal(X + 2 * s, e - s, result, mod);
}
#else
// n = e - s
// Y = X[2s:2e]
// s(i) = (Y[1]*x+Y[0])(Y[3]x+Y[2])...(Y[2i+1]x+Y[2i])
// return s(n-1)
// size s(n-1) = n + 1
template <typename T>
SL REQUIRES((is_native_integer<T>::value)) RETURN(void)
    poly_batch_mul_mod_internal(const T* X, int s, int e, T* result,
                                int64 mod) {
  static_assert(std::is_unsigned<T>::value, "T must be unsigned");
  const int n = e - s;
  if (n == 1) {
    copy(X + s * 2, X + e * 2, result);
    return;
  }
  const int half = n >> 1;
  vector<T> A(half + 1);
  vector<T> B(n - half + 1);
#if ENABLE_OPENMP
#pragma omp parallel sections if (n > 5000)
#endif
  {
#if ENABLE_OPENMP
#pragma omp section
#endif
    poly_batch_mul_mod_internal(X, s, s + half, &A[0], mod);
#if ENABLE_OPENMP
#pragma omp section
#endif
    poly_batch_mul_mod_internal(X, s + half, e, &B[0], mod);
  }
  poly_mul(&A[0], half + 1, &B[0], n - half + 1, result, mod);
}
#endif

// Y = X
// s(i) = (Y[1]*x+Y[0])(Y[3]x+Y[2])...(Y[2i+1]x+Y[2i])
// return s(n-1)
// size s(n-1) = n + 1
template <typename T>
SL REQUIRES((is_native_integer<T>::value)) RETURN(void)
    poly_batch_mul_mod(const T* X, const int n, T* result, int64 mod) {
  typedef typename std::make_unsigned<T>::type unsignedT;
  poly_batch_mul_mod_internal<unsignedT>((const unsignedT*)X, 0, n,
                                         (unsignedT*)result, mod);
}

// n = size X / 2
// Y = X
// s(i) = (Y[1]*x+Y[0])(Y[3]x+Y[2])...(Y[2i+1]x+Y[2i])
// return s(n-1)
// size s(n-1) = n + 1
template <typename T>
SL REQUIRES((is_native_integer<T>::value)) RETURN(vector<T>)
    poly_batch_mul_mod(const vector<T>& X, int64 mod) {
  const int n = (int)X.size();
  vector<T> result(n / 2 + 1);
  poly_batch_mul_mod(&X[0], n / 2, &result[0], mod);
  return result;
}

#if 0
// n = e - s
// Y = X[2s:2e]
// s(i) = (Y[1]*x+Y[0])(Y[3]x+Y[2])...(Y[2i+1]x+Y[2i])
// return s(0) + s(2) + s(3) + ... + s(n-1)
template <typename T>
SL REQUIRES((is_native_integer<T>::value)) RETURN(vector<T>)
poly_batch_mul_acc_mod(const vector<T>& X, int s, int e, uint64 mod) {
  const int n = e - s;
  if (n == 1) {
    return vector<T>(X.begin() + s * 2, X.begin() + e * 2);
  }

  const int half = n / 2;
  vector<T> A, B, C;
#if ENABLE_OPENMP
#pragma omp parallel sections if (n > 5000)
#endif
  {
#if ENABLE_OPENMP
#pragma omp section
#endif
    A = poly_batch_mul_acc_mod(X, s, s + half, mod);
#if ENABLE_OPENMP
#pragma omp section
#endif
    B = poly_batch_mul_acc_mod(X, s + half, e, mod);
#if ENABLE_OPENMP
#pragma omp section
#endif
    C = poly_batch_mul_mod(vector<T>(X.begin() + s * 2, X.begin() + (s + half)*2), mod);
  }

  B = poly_mul(B, C, mod);
  return poly_add(A, B, mod);
}

// n = X.size() / 2
// Y = X
// s(i) = (Y[1]*x+Y[0])(Y[3]x+Y[2])...(Y[2i+1]x+Y[2i])
// return s(0) + s(2) + s(3) + ... + s(n-1)
template <typename T>
SL REQUIRES((is_native_integer<T>::value)) RETURN(vector<T>)
poly_batch_mul_acc_mod(const vector<T>& X, uint64 mod) {
  return poly_batch_mul_acc_mod(X, 0, X.size() / 2, mod);
}

// n = e - s
// Y = X[2s:2e]
// s(i) = (Y[1]*x+Y[0])(Y[3]x+Y[2])...(Y[2i+1]x+Y[2i])
// M = s(n-1)
// return s(0) + s(2) + s(3) + ... + s(n-1)
template <typename T>
SL REQUIRES((is_native_integer<T>::value)) RETURN(vector<T>)
poly_batch_mul_acc_mod(const vector<T>& X, int s, int e, vector<T>& M, uint64 mod) {
  vector<T> Y(X.begin() + s * 2, X.begin() + e * 2);
  M = poly_batch_mul_mod(Y, mod);
  return poly_batch_mul_acc_mod(Y, mod);
}
#else
// n = e - s
// Y = X[2s:2e]
// s(i) = (Y[1]*x+Y[0])(Y[3]x+Y[2])...(Y[2i+1]x+Y[2i])
// M = s(n-1)
// return s(0) + s(2) + s(3) + ... + s(n-1)
template <typename T>
SL REQUIRES((is_native_integer<T>::value)) RETURN(vector<T>)
    poly_batch_mul_acc_mod(const vector<T>& X, int s, int e, vector<T>& M,
                           uint64 mod) {
  const int n = e - s;
  if (n == 1) {
    vector<T> t(X.begin() + s * 2, X.begin() + e * 2);
    M = t;
    return t;
  }
  vector<T> C, D;
  const int half = n / 2;
  vector<T> A, B;
#if ENABLE_OPENMP
#pragma omp parallel sections if (n > 5000)
#endif
  {
#if ENABLE_OPENMP
#pragma omp section
#endif
    A = poly_batch_mul_acc_mod(X, s, s + half, C, mod);
#if ENABLE_OPENMP
#pragma omp section
#endif
    B = poly_batch_mul_acc_mod(X, s + half, e, D, mod);
  }
#if ENABLE_OPENMP
#pragma omp parallel sections if (n > 5000)
#endif
  {
#if ENABLE_OPENMP
#pragma omp section
#endif
    B = poly_mul(B, C, mod);
#if ENABLE_OPENMP
#pragma omp section
#endif
    M = poly_mul(C, D, mod);
  }
  return poly_add(A, B, mod);
}

// n = X.size() / 2
// Y = X
// s(i) = (Y[1]*x+Y[0])(Y[3]x+Y[2])...(Y[2i+1]x+Y[2i])
// return s(0) + s(2) + s(3) + ... + s(n-1)
template <typename T>
SL REQUIRES((is_native_integer<T>::value)) RETURN(vector<T>)
    poly_batch_mul_acc_mod(const vector<T>& X, uint64 mod) {
  vector<T> C;
  return poly_batch_mul_acc_mod(X, 0, X.size() / 2, C, mod);
}
#endif

// f(4e8)%99999999907 = 16815920030
// Compute (0! + 1! + 2! + ... + n!) % p
// The complexity is M(p^(1/2))
struct FactSumModer {
  FactSumModer(uint64 p) : p(p) { init(); }

  int64 cal(uint64 n) {
    if (n >= p) n = p - 1;
    if (n < q) return preFactSum[n];

    auto m = static_cast<int64>(sqrt(n));
    uint64 ret = 1;

    // Prepare data for computing P
    vector<uint64> X((m - 1) * 2);
    for (int i = 0; i < m - 1; ++i) {
      X[i * 2] = i + 1;
      X[i * 2 + 1] = m;
    }

    vector<uint64> V(m);
    for (int i = 0; i < m; ++i) {
      V[i] = i;
    }

    // Compute P
    vector<uint64> YQ;
    auto YP = poly_batch_mul_acc_mod(X, 0, static_cast<int>(m - 1), YQ, p);
    YP[0] = add_mod(YP[0], 1, p);
    auto P = poly_evaluate_mod_bls(YP, V, p);

    // Prepare data for computing Q
    // YQ *= (m + xm)
    YQ.resize(m + 1);
    YQ[m] = YQ[m - 1];
    for (int i = static_cast<int>(m - 1); i >= 1; --i)
      YQ[i] = add_mod(YQ[i], YQ[i - 1], p);
    for (auto& i : YQ) i = mul_mod_ex(i, m, p);

    // V.extend(m)
    V.push_back(m);

    // Compute Q
    auto Q = poly_evaluate_mod_bls(YQ, V, p);
    for (int i = 1; i <= m; ++i) {
      Q[i] = mul_mod_ex(Q[i], Q[i - 1], p);
    }

    // Compute P
    X.resize((m - 1) * 2);
    V.resize(m);
    // deg y = m - 1

    // Compute result
    int64 result = P[0];
    for (int i = 1; i < m; ++i) {
      uint64 t = mul_mod_ex(P[i], Q[i - 1], p);
      result = add_mod(result, t, p);
    }

    uint64 last = Q[m - 1];
    for (int64 i = m * m; i <= static_cast<int64>(n); ++i) {
      result = add_mod(result, last, p);
      last = mul_mod_ex(last, i + 1, p);
    }
    return result;
  }

  void init() {
    q = static_cast<uint64>(sqrt(p));
    while (q * q < p) ++q;
    q <<= 1;
    q += 1;
    preFact.resize(q);
    preFactSum.resize(q);
    init_seq_prod<uint64>(&preFact[0], 1, q - 1, p);
    preFactSum[0] = preFact[0];
    for (int i = 1; i < q; ++i) {
      preFactSum[i] = add_mod(preFactSum[i - 1], preFact[i], p);
    }
  }

  vector<uint64> preFact, preFactSum;
  uint64 p;
  uint64 q;
};

// Binomial number moder for large P
// The complexity is log(m) M(p^(1/2))
struct CombModerEx {
  CombModerEx(uint64 P) : P(P), fmoder(P) {}
  int64 s(int64 x) { return x & 1 ? P - 1 : 1; }
  int64 comb(int64 m, int64 n) {
    if (m < 0 || n > m) return 0;
    if (n == m || n == 0) return 1;
    if (n == 1 || n == m - 1) return m % P;

    int64 pp = 0;
    int64 dist = m - n;

    for (int64 mm = m / P, nn = n / P, dd = dist / P; mm;
         mm /= P, nn /= P, dd /= P) {
      pp += mm - nn - dd;
    }
    if (pp) return 0;
    int64 l = 1, r = 1;
    for (int64 x = m; x; x /= P) {
      l = mul_mod_ex(l, s(x / P), P);
      l = mul_mod_ex(l, fmoder.cal(x % P), P);
    }
    for (int64 x = n; x; x /= P) {
      r = mul_mod_ex(r, s(x / P), P);
      r = mul_mod_ex(r, fmoder.cal(x % P), P);
    }
    for (int64 x = dist; x; x /= P) {
      r = mul_mod_ex(r, s(x / P), P);
      r = mul_mod_ex(r, fmoder.cal(x % P), P);
    }

    return mul_mod_ex(inv_of(r, P), l, P);
  }

  uint64 P;
  FactModer fmoder;
};

// Initialize the bernoulli numbers.
// B[1] = -1/2
// invs[n] should be available.
SL void init_bernoulli_number(int64* dest, int64 n, int64* invs, int64 mod) {
  vector<uint64> t(n);
  uint64 v = 1;
  for (int64 i = 0; i < n; ++i) {
    v = mul_mod_ex(v, invs[i + 1], mod);
    t[i] = v;
  }

  auto result = poly_inv_mod<uint64>(t, static_cast<int>(n), mod);

  uint64 c = 1;
  dest[0] = result[0];
  for (int i = 1; i < n; ++i) {
    c = mul_mod_ex(c, i, mod);
    dest[i] = mul_mod_ex(result[i], c, mod);
  }
}

SL void init_bernoulli_number(int64* dest, int64 n, int64 mod) {
  vector<uint64> invs(n + 1);
  init_inv(reinterpret_cast<int64*>(&invs[0]), n + 1, mod);
  init_bernoulli_number(dest, n, reinterpret_cast<int64*>(&invs[0]), mod);
}

// Compute 1^k + 2^k + ... n^k based on bernoulli number
// See
// https://en.wikipedia.org/wiki/Bernoulli_number#Sum_of_powers
// https://blog.csdn.net/acdreamers/article/details/38929067
struct PowerSumModerB {
  PowerSumModerB(int64 mod, int64 maxk = 128)
      : mod(mod), maxk(maxk), BNL(NULL), invs(NULL) {
    init(maxk);
  }

  ~PowerSumModerB() { reset(); }

  void reset() {
    if (BNL) {
      delete[] BNL;
      BNL = NULL;
    }
    if (invs) {
      delete[] invs;
      invs = NULL;
    }
  }

  void init(int64 maxk) {
    reset();

    this->maxk = maxk;
    BNL = new int64[maxk + 1];
    invs = new int64[maxk + 2];
    init_inv(invs, maxk + 2, mod);
    init_bernoulli_number(BNL, maxk + 1, invs, mod);

    BNL[1] = mod - BNL[1];
  }

  // n + 1, n, ..., n-k+1 is not divisible by mod
  // 2,3,...k+1 is not divisible by mod
  int64 cal(int64 n, int64 k) {
    PE_ASSERT(k <= maxk);

    int64 ret = 0;

    int64 invn = power_mod_ex(n % mod, mod - 2, mod);
    int64 c = power_mod_ex(n % mod, k + 1, mod);

    for (int64 i = 0; i <= k; ++i) {
      if (i > 0) {
        c = mul_mod_ex(c, regulate_mod(k + 2 - i, mod), mod);
        c = mul_mod_ex(c, invs[i], mod);
        c = mul_mod_ex(c, invn, mod);
      }

      if (c == 0) {
        break;
      }

      ret += mul_mod_ex(c, BNL[i], mod);
      if (ret >= mod) ret -= mod;
    }
    ret = mul_mod_ex(ret, invs[k + 1], mod);
    return ret;
  }

  int64 cal_safe(int64 n, int64 k) {
    PE_ASSERT(k <= maxk);

    int64 ret = 0;

    int64 invn = power_mod_ex(n % mod, mod - 2, mod);
    int64 c = power_mod_ex(n % mod, k + 1, mod);

    int64 d = 0;
    for (int64 i = 0; i <= k; ++i) {
      if (i > 0) {
        int64 A, B;

        tie(A, B) = extract_factor(k + 2 - i, mod);
        d += B;
        c = mul_mod_ex(c, regulate_mod(A, mod), mod);

        tie(A, B) = extract_factor(i, mod);
        d -= B;
        c = mul_mod_ex(c, invs[A], mod);

        c = mul_mod_ex(c, invn, mod);
      }
      if (c == 0) {
        break;
      }
      if (d == 0) {
        ret += mul_mod_ex(c, BNL[i], mod);
        if (ret >= mod) ret -= mod;
      }
    }
    ret = mul_mod_ex(ret, invs[k + 1], mod);
    return ret;
  }

  int64 mod;
  int64 maxk;
  int64* BNL;
  int64* invs;
};

struct PowerSumModerB1 {
  PowerSumModerB1(int64 mod, int64 maxk = 128)
      : mod(mod), maxk(maxk), BNL(NULL), invs(NULL) {
    init(maxk);
  }

  ~PowerSumModerB1() { reset(); }

  void reset() {
    if (BNL) {
      delete[] BNL;
      BNL = NULL;
    }
    if (invs) {
      delete[] invs;
      invs = NULL;
    }
  }

  void init(int64 maxk) {
    reset();

    this->maxk = maxk;
    BNL = new int64[maxk + 1];
    invs = new int64[maxk + 2];
    init_inv(invs, maxk + 2, mod);
    init_bernoulli_number(BNL, maxk + 1, invs, mod);
  }

  // n + 1, n, ..., n-k+1 is not divisible by mod
  // 2,3,...k+1 is not divisible by mod
  int64 cal(int64 n, int64 k) {
    PE_ASSERT(k <= maxk);

    const int64 n1 = (n + 1) % mod;
    const int64 k1 = k + 1;

    int64 ret = 0;

    int64 c = 1 % mod;
    for (int64 i = 1; i <= k1; ++i) {
      c = mul_mod_ex(c, regulate_mod(k1 - i + 1, mod), mod);
      c = mul_mod_ex(c, invs[i], mod);
      c = mul_mod_ex(c, n1, mod);

      if (c == 0) {
        break;
      }

      ret += mul_mod_ex(c, BNL[k1 - i], mod);
      if (ret >= mod) ret -= mod;
    }
    ret = mul_mod_ex(ret, invs[k1], mod);
    return ret;
  }

  int64 cal_safe(int64 n, int64 k) {
    PE_ASSERT(k <= maxk);

    const int64 n1 = (n + 1) % mod;
    const int64 k1 = k + 1;

    int64 ret = 0;

    int64 c = 1 % mod;
    int64 d = 0;
    for (int64 i = 1; i <= k1; ++i) {
      int64 A, B;

      tie(A, B) = extract_factor(k1 - i + 1, mod);
      d += B;
      c = mul_mod_ex(c, regulate_mod(A, mod), mod);

      tie(A, B) = extract_factor(i, mod);
      d -= B;
      c = mul_mod_ex(c, invs[A], mod);

      c = mul_mod_ex(c, n1, mod);

      if (c == 0) {
        break;
      }
      if (d == 0) {
        ret += mul_mod_ex(c, BNL[k1 - i], mod);
        if (ret >= mod) ret -= mod;
      }
    }
    ret = mul_mod_ex(ret, invs[k1], mod);
    return ret;
  }

  int64 mod;
  int64 maxk;
  int64* BNL;
  int64* invs;
};

SL int64 power_sum(int64 n, int64 k, int64 mod) {
  return PowerSumModerB(mod, k).cal(n, k);
}

SL int64 power_sum_safe(int64 n, int64 k, int64 mod) {
  return PowerSumModerB(mod, k).cal_safe(n, k);
}

// gf_first, gf_at is good for the case size(A) is small.
// Otherwise, A.inv(n) * B is better.

// Finds the coefficient of x^0..x^n of f such that: A*f = B
// Returns empty vector if there is no integer solution.
// O(size(A) * n)
SL vector<int64> gf_first(const vector<int64>& A, const vector<int64>& B,
                          const int n, const int64 mod) {
  const int sa = sz(A);
  const int sb = sz(B);
  PE_ASSERT(sa > 0);
  PE_ASSERT(sb > 0);

  int64 v, u;
  int has = solve_linear_equation<int64>(A[0], 1, mod, v, u);
  if (!has) return vector<int64>();

  vector<int64> result(n + 1, 0);

  // if u < mod, we have more than one solution.
  PE_ASSERT(u == mod);
  const int64 invA0 = v;
  result[0] = invA0 * B[0] % mod;

  for (int i = 1; i <= n; ++i) {
    int64 t = regulate_mod(i < sb ? B[i] : 0, mod);
    for (int j = 1; j <= min(i, sa - 1); ++j) {
      t = sub_mod(t, (j < sa ? A[j] : 0) * result[i - j] % mod, mod);
    }
    result[i] = invA0 * t % mod;
  }

  return result;
}

// gf_first, gf_at is good for the case size(A) is small.
// Otherwise, A.inv(n) * B is better.

// Finds the coefficient of x^0..x^n of f such that: A*f = B
// Returns empty vector if there is no integer solution.
// O(size(A) * n)
SL vector<int64> gf_first(const NModPoly& A, const NModPoly& B, const int n) {
  return gf_first(A.data, B.data, n, A.mod);
}

// Finds the coefficient of x^n of f such that: A*f = B
// Returns -1 if there is no integer solution.
// O(size(A)^3 * log n) for big n
SL int64 gf_at(const vector<int64>& A, const vector<int64>& B, const int64 n,
               const int64 mod) {
  const int sa = sz(A);
  const int sb = sz(B);
  PE_ASSERT(sa > 0);
  PE_ASSERT(sb > 0);

  int64 v, u;
  int has = solve_linear_equation<int64>(A[0], 1, mod, v, u);
  if (!has) return -1;

  const int64 m = min(static_cast<int64>(max(sa - 1, sb - 1)), n);
  vector<int64> result(m + 1, 0);

  // if u < mod, we have more than one solution.
  PE_ASSERT(u == mod);
  const int64 invA0 = v;
  result[0] = invA0 * B[0] % mod;

  for (int i = 1; i <= m; ++i) {
    int64 t = regulate_mod(i < sb ? B[i] : 0, mod);
    for (int j = 1; j <= min(i, sa - 1); ++j) {
      t = sub_mod(t, (j < sa ? A[j] : 0) * result[i - j] % mod, mod);
    }
    result[i] = invA0 * t % mod;
  }

  if (m == n) {
    return result[m];
  }

  const int64 D = sa - 1;
  const int64 size = D * D;
  string data(size * sizeof(int64) * 3, '\0');
  auto* buffer = (int64*)data.c_str();

  int64* mat = buffer;
  int64* res = mat + size;
  int64* tmp = res + size;

  for (int i = 0; i < D; ++i) {
    mat[i] = invA0 * regulate_mod(i + 1 < sa ? -A[i + 1] : 0, mod) % mod;
  }
  for (int i = 1; i < D; ++i) {
    (mat + i * D)[i - 1] = 1;
  }
  for (int i = 0; i < D; ++i) {
    res[i] = result[m - i];
  }

  for (int64 t = n - m; t > 0; t >>= 1) {
    if (t & 1) {
      mat_mul_vec_mod(mat, res, tmp, mod, static_cast<int>(D));
      swap(res, tmp);
    }
    if (t > 1) {
      mat_mul_mat_mod(mat, mat, tmp, mod, static_cast<int>(D));
      swap(mat, tmp);
    }
  }
  return res[0];
}

// Finds the coefficient of x^n of f such that: A*f = B
// Returns -1 if there is no integer solution.
// O(size(A)^3 * log n) for big n
SL int64 gf_at(const NModPoly& A, const NModPoly& B, const int64 n) {
  return gf_at(A.data, B.data, n, A.mod);
}

// Berlekamp Massey
SL NModPoly find_minimal_poly(const NModPoly& s) {
  const int m = static_cast<int>(s.data.size());
  const int n = m >> 1;
  const int64 mod = s.mod;
  PE_ASSERT(n * 2 == m);

  NModPoly r0{{1}, mod};
  r0 = r0 << m;
  NModPoly r1(s);
  NModPoly v0{{0}, mod};
  NModPoly v1{{1}, mod};

  while (n + 1 <= r1.deg()) {
    NModPoly q, r;
    tie(q, r) = poly_div_and_mod(r0, r1);
    NModPoly v(v0 - q * v1);
    v0 = std::move(v1);
    v1 = std::move(v);
    r0 = std::move(r1);
    r1 = std::move(r);
  }
  v1 = std::move(inv_of(v1[0], mod) * v1);
  reverse(v1.data.begin(), v1.data.end());
  return v1;
}

SL int64 nth_element(const NModPoly& s, int64 n, const NModPoly& min_poly) {
  if (n <= s.deg()) {
    return s[static_cast<int>(n)];
  }

  auto r = n % min_poly;
  const int m = r.deg();
  int64 ans = 0;
  for (int i = 0; i <= m; ++i) {
    ans = add_mod(ans, s[i] * r[i] % s.mod, s.mod);
  }
  return ans;
}

SL NModPoly find_linear_recurrence(const NModPoly& s) {
  const int len = static_cast<int>(s.data.size());
  for (int n = 2; n < len; n += 2) {
    auto use = s.lowerTerms(n);
    auto min_poly = find_minimal_poly(use);
    int ok = 1;
    for (int i = n; i < len; ++i) {
      auto value = nth_element(use, i, min_poly);
      if (value != s[i]) {
        ok = 0;
        break;
      }
    }
    if (ok) {
      return min_poly;
    }
  }
  return NModPoly();
}

SL int64 nth_element(const NModPoly& s, int64 n) {
  if (n <= s.deg()) {
    return s[static_cast<int>(n)];
  }

  auto min_poly = find_linear_recurrence(s);
  if (min_poly.deg() > 0) {
    return nth_element(s, n, min_poly);
  }
  return -1;
}
#endif
