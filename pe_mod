#ifndef __PE_MOD__
#define __PE_MOD__

#include "pe_base"
#include "pe_int128"
#include "pe_type_traits"

// Modular arithmetic
template <typename T, typename M>
SL REQUIRES((is_native_integer<T>::value && is_native_integer<M>::value &&
             std::is_signed<T>::value && std::is_signed<M>::value))
    RETURN_T(IntPromotionT(T, M)) regulate_mod(T a, M mod) {
  PE_ASSERT(mod >= 1);
  if (a >= 0) {
    return a >= mod ? a % mod : a;
  } else {
    auto tmp = a % mod;
    if (tmp < 0) tmp += mod;
    return tmp;
  }
}

template <typename T, typename M>
SL REQUIRES((is_native_integer<T>::value && is_native_integer<M>::value &&
             std::is_signed<T>::value && std::is_unsigned<M>::value))
    RETURN_T(IntPromotionT(T, M)) regulate_mod(T a, M mod) {
  PE_ASSERT(mod >= 1);
  if (a >= 0) {
    return a >= mod ? a % mod : a;
  } else {
    auto t = -a;
    if (t >= mod) t %= mod;
    return t == 0 ? 0 : mod - t;
  }
}

template <typename T, typename M>
SL REQUIRES((is_native_integer<T>::value && is_native_integer<M>::value &&
             std::is_unsigned<T>::value)) RETURN_T(IntPromotionT(T, M))
    regulate_mod(T a, M mod) {
  PE_ASSERT(mod >= 1);
  typedef IntPromotion(T, M) ResultType;
  ResultType b = a, m = mod;
  if (b >= m) b %= m;
  return b;
}

template <typename T>
SL REQUIRES((is_native_integer<T>::value)) RETURN(T) regulate_mod(T a, T mod) {
  return regulate_mod<T, T>(a, mod);
}

template <typename T, typename M>
SL REQUIRES((is_native_integer<T>::value && is_native_integer<M>::value))
    RETURN_T(IntPromotionT(T, M)) add_mod_impl(T a, T b, M mod) {
  typedef IntPromotion(T, M) ResultType;
  auto t0 = a;
  t0 += b;
  ResultType t1 = t0, m = mod;
  if (t1 >= m) t1 -= m;
  return t1;
}

template <typename T1, typename T2, typename M>
SL REQUIRES((is_native_integer<T1>::value && is_native_integer<T2>::value &&
             is_native_integer<M>::value)) RETURN_T(IntPromotionT(T1, T2, M))
    add_mod(T1 a, T2 b, M mod) {
  typedef IntPromotion(T1, T2) T;
  return add_mod_impl<T, M>(a, b, mod);
}

template <typename T, typename M>
SL REQUIRES((is_native_integer<T>::value && is_native_integer<M>::value))
    RETURN(IntPromotion(T, M)) sub_mod_impl(T a, T b, M mod) {
  return a >= b ? a - b : mod - b + a;
}

template <typename T1, typename T2, typename M>
SL REQUIRES((is_native_integer<T1>::value && is_native_integer<T2>::value &&
             is_native_integer<M>::value)) RETURN_T(IntPromotionT(T1, T2, M))
    sub_mod(T1 a, T2 b, M mod) {
  typedef IntPromotion(T1, T2) T;
  return sub_mod_impl<T, M>(a, b, mod);
}

template <typename T, typename M>
SL REQUIRES((is_native_integer<T>::value && is_native_integer<M>::value))
    RETURN_T(IntPromotionT(T, M)) mul_mod_impl(T a, T b, M mod) {
  return a * b % mod;
}

template <typename T1, typename T2, typename M>
SL REQUIRES((is_native_integer<T1>::value && is_native_integer<T2>::value &&
             is_native_integer<M>::value))
    RETURN_T(IntPromotionT(T1, T2, int64, M)) mul_mod(T1 a, T2 b, M mod) {
  typedef IntPromotion(T1, T2) T;
  typedef typename AtLeastInt64<T>::type atLeastInt64T;
  return mul_mod_impl<atLeastInt64T, M>(a, b, mod);
}

#if PE_HAS_INT128
SL uint64 mod128_64(uint128 a, uint64 b) {
#if defined(COMPILER_GNU) && PE_X86_64
  // Note: if a / b > uint64_max, an exception is thrown.
  uint64 q, r;
  __asm__("divq\t%4"
          : "=a"(q), "=d"(r)
          : "0"(uint64(a)), "1"(uint64(a >> 64)), "rm"(b));
  return r;
#else
  return a % b;
#endif
}
#endif

#if defined(COMPILER_GNU) && PE_X86_64
template <typename T>
SL REQUIRES((is_native_integer<T>::value && is_unsigned<T>::value))
    RETURN(uint64) mul_mod_ex_dis(uint64 a, uint64 b, uint64 mod) {
  if (mod >> 32) {
    uint64 q, r;
    __asm__(
        "movq %2,%%rax\n\t"
        "mulq %3\n\t"
        "divq %4\n\t"
        : "=a"(q), "=d"(r)
        : "0"(uint64(a)), "1"(uint64(b)), "rm"(uint64(mod)));
    return r;
  } else {
    uint32 q, r;
    __asm__(
        "movl %2,%%eax\n\t"
        "mull %3\n\t"
        "divl %4\n\t"
        : "=a"(q), "=d"(r)
        : "0"(uint32(a)), "1"(uint32(b)), "rm"(uint32(mod)));
    return r;
  }
}

template <typename T>
SL REQUIRES((is_native_integer<T>::value && is_signed<T>::value)) RETURN(int64)
    mul_mod_ex_dis(int64 a, int64 b, int64 mod) {
  if (static_cast<uint64>(mod) >> 31) {
    int64 q, r;
    __asm__(
        "movq %2,%%rax\n\t"
        "imulq %3\n\t"
        "idivq %4\n\t"
        : "=a"(q), "=d"(r)
        : "0"(a), "1"(b), "rm"(mod));
    return r;
  } else {
    int32 q, r;
    __asm__(
        "movl %2,%%eax\n\t"
        "imull %3\n\t"
        "idivl %4\n\t"
        : "=a"(q), "=d"(r)
        : "0"(int32(a)), "1"(int32(b)), "rm"(int32(mod)));
    return r;
  }
}
#endif

SL void mul_mod_ex_slow_warning_once() {
  static atomic_int WARNING_ONCE_FLAG{0};
  if (WARNING_ONCE_FLAG.exchange(1) == 0) {
    fprintf(stderr, "mul_mod_ex may be very slow.\n");
  }
}

#if defined(COMPILER_MSVC) && PLATFORM_WIN && PE_X86_64

extern "C" {
typedef uint64 (*MulModFunctionPointerType)(uint64, uint64, uint64);
}

#if 0
.CODE

MulModShellCode PROC
	mov rax, rcx
	mul rdx
    div r8
	mov rax, rdx
    ret
MulModShellCode ENDP

END
#endif
const char __MulModShellCode[] =
    "\x48\x8b\xc1\x48\xf7\xe2\x49\xf7\xf0\x48\x8b\xc2\xc3";
int __MakeMulModShellCodeExecutable() {
  DWORD dwOld = 0;
  VirtualProtect((void*)__MulModShellCode, sizeof(__MulModShellCode),
                 PAGE_EXECUTE_READWRITE, &dwOld);
  return 0;
}
const static int __init_code_data_once = __MakeMulModShellCodeExecutable();
#endif

template <typename T1, typename T2, typename M>
SL REQUIRES((is_native_integer<T1>::value && is_native_integer<T2>::value &&
             is_native_integer<M>::value))
    RETURN_T(IntPromotionT(T1, T2, int64, M)) mul_mod_ex(T1 a, T2 b, M mod) {
  typedef IntPromotion(T1, T2) T;
  typedef typename AtLeastInt64<T>::type atLeastInt64T;
  typedef IntPromotion(atLeastInt64T, T) ResultType;

#if defined(COMPILER_GNU) && PE_X86_64
  // We have a disassembly version
  return (ResultType)mul_mod_ex_dis<ResultType>(a, b, mod);
#else
  if (mod <= PE_SOI63) {
    return mul_mod_impl<atLeastInt64T, M>(a, b, mod);
  }
#if PE_HAS_INT128
  return (ResultType)mul_mod_impl<int128, M>(a, b, mod);
#else

  // The openmp has issue about long double on windows.
  // Seems caused by thread library.
  // https://sourceforge.net/p/mingw-w64/bugs/678/
#if defined(COMPILER_GNU) && PLATFORM_WIN && ENABLE_OPENMP
  constexpr bool GNU_ON_WINDOWS_WITH_OPENMP = true;
#else
  constexpr bool GNU_ON_WINDOWS_WITH_OPENMP = false;
#endif
  constexpr bool CAN_USE_LONG_DOUBLE =
      sizeof(long double) > sizeof(double) && !GNU_ON_WINDOWS_WITH_OPENMP;

  if (CAN_USE_LONG_DOUBLE) {
    const int64 x = a, y = b, m = mod;
    int64 r = (x * y - (int64)(((long double)x * y) / m) * m);
    if (r >= m) r -= r / m * m;
    if (r < 0) r += m;
    return r;
  }

#if defined(COMPILER_MSVC) && PLATFORM_WIN && PE_X86_64
  return (ResultType)((MulModFunctionPointerType)(
      unsigned char*)__MulModShellCode)((uint64)a, (uint64)b, (uint64)mod);
#endif

  mul_mod_ex_slow_warning_once();
// 3 other implementations
#if 0
  // Mpz based implementation
  // GMP_LIMB_BITS == 64 and GMP_NAIL_BITS == 0
  mpz_t A;
  mpz_init2(A, 64);
  mpz_t B;
  mpz_init2(B, 64);
  A[0]._mp_size = 1;
  A[0]._mp_d[0] = a;

  B[0]._mp_size = 1;
  B[0]._mp_d[0] = b;

  mpz_t M;
  mpz_init2(M, 64);
  M[0]._mp_size = 1;
  M[0]._mp_d[0] = mod;

  mpz_mul(A, A, B);
  mpz_mod(A, A, M);

  auto ret = A[0]._mp_d[0];
  mpz_clear(A);
  mpz_clear(B);
  mpz_clear(M);
  return ret;
#elif 1
  const uint64 ua = static_cast<uint64>(a);
  const uint64 ub = static_cast<uint64>(b);
  const uint64 umod = static_cast<uint64>(mod);
  if (ua == 0 || ub == 0) {
    return 0;
  }
  if (ua <= ub) {
    uint64 ret = 0;
    int used = pe_clzll(ua);
    const int d = pe_clzll(ub);
    const uint64 mask = (1ULL << d) - 1;
    while (used < 64) {
      const int now = min(64 - used, d);
      const uint64 t0 = (ua >> (64 - used - now)) & mask;
      const uint64 t1 = t0 * ub % umod;
      ret = (ret << now) % umod;
      ret += t1;
      if (ret >= umod) ret -= umod;
      used += now;
    }
    return ret;
  } else {
    uint64 ret = 0;
    int used = pe_clzll(ub);
    const int d = pe_clzll(ua);
    const uint64 mask = (1ULL << d) - 1;
    while (used < 64) {
      const int now = min(64 - used, d);
      const uint64 t0 = (ub >> (64 - used - now)) & mask;
      const uint64 t1 = t0 * ua % umod;
      ret = (ret << now) % umod;
      ret += t1;
      if (ret >= umod) ret -= umod;
      used += now;
    }
    return ret;
  }
#elif 0
  atLeastInt64T ret = 0;
  atLeastInt64T flag = b;
  for (atLeastInt64T d = 1; d <= (atLeastInt64T)a; d <<= 1) {
    if (d & a) {
      ret = (ret + flag) % mod;
    }
    flag = (flag << 1) % mod;
  }
  return (ResultType)ret;
#endif

#endif

#endif
}

// It's expected that all elements in b are prime.
// The behavior is undefined if it's not satisified.
template <typename T, typename M>
SL REQUIRES((is_native_integer<T>::value && is_native_integer<M>::value))
    RETURN_T(IntPromotionT(T, M))
        frac_mod_impl(std::vector<T> a, std::vector<T> b, M mod) {
  typedef IntPromotion(T, M) ResultType;
  ResultType ret = 1;
  const int size = b.size();
  int remain = size;
  for (auto iter : a) {
    for (int i = 0; remain > 0 && i < size; ++i)
      if (b[i] != 1 && (iter % b[i] == 0)) {
        iter /= b[i];
        b[i] = 1;
        --remain;
      }
    ret = mul_mod(ret, iter % mod, mod);
  }
  return ret;
}

template <typename T1, typename T2 = T1, typename M>
SL REQUIRES((is_native_integer<T1>::value && is_native_integer<T2>::value &&
             is_native_integer<M>::value))
    RETURN_T(IntPromotionT(T1, T2, int64, M))
        frac_mod(std::vector<T1> a, std::vector<T2> b, M mod) {
  typedef IntPromotion(T1, T2) T;
  typedef typename AtLeastInt64<T>::type atLeastInt64T;
  return frac_mod_impl<atLeastInt64T, M>(a, b, mod);
}

template <typename T1, typename T2, typename M>
SL REQUIRES((is_native_integer<T1>::value && is_native_integer<T2>::value &&
             is_native_integer<M>::value)) RETURN_T(IntPromotionT(T1, M))
    power_mod_impl(T1 x, T2 n, M mod) {
  if (mod == 1) return 0;
  typedef IntPromotion(T1, M) ResultType;

  ResultType ret = 1;
  auto y = regulate_mod(x, mod);
  for (; n; n >>= 1) {
    if (n & 1) ret = mul_mod(ret, y, mod);
    y = mul_mod(y, y, mod);
  }
  return ret;
}

template <typename T1, typename T2, typename M>
SL REQUIRES((is_native_integer<T1>::value && is_native_integer<T2>::value &&
             is_native_integer<M>::value)) RETURN_T(IntPromotionT(T1, int64, M))
    power_mod(T1 x, T2 n, M mod) {
  typedef typename AtLeastInt64<T1>::type atLeastInt64T1;
  return power_mod_impl<atLeastInt64T1, T2, M>(x, n, mod);
}

template <typename T1, typename T2, typename M>
SL REQUIRES((is_native_integer<T1>::value && is_native_integer<T2>::value &&
             is_native_integer<M>::value)) RETURN_T(IntPromotionT(T1, M))
    power_mod_ex_impl(T1 x, T2 n, M mod) {
  if (mod == 1) return 0;
  typedef IntPromotion(T1, M) ResultType;

  ResultType ret = 1;
  auto y = regulate_mod(x, mod);
  for (; n; n >>= 1) {
    if (n & 1) ret = mul_mod_ex(ret, y, mod);
    y = mul_mod_ex(y, y, mod);
  }
  return ret;
}

template <typename T1, typename T2, typename M>
SL REQUIRES((is_native_integer<T1>::value && is_native_integer<T2>::value &&
             is_native_integer<M>::value)) RETURN_T(IntPromotionT(T1, int64, M))
    power_mod_ex(T1 x, T2 n, M mod) {
  typedef typename AtLeastInt64<T1>::type atLeastInt64T1;
  return power_mod_ex_impl<atLeastInt64T1, T2, M>(x, n, mod);
}

struct init_direct_t {};
static const init_direct_t __init_direct{};
struct fake_int128 {};

template <typename S, typename B>
struct mtype_policy {
  typedef S ints;
  typedef B intb;
  static ints add(ints a, ints b, ints mod) {
    intb c = (intb)a + b;
    if (c >= mod) c -= mod;
    return static_cast<ints>(c);
  }
  static ints sub(ints a, ints b, ints mod) {
    intb c = (intb)a - b;
    if (c < 0) c += mod;
    return static_cast<ints>(c);
  }
  static ints mul(ints a, ints b, ints mod) {
    intb c = (intb)a * b % mod;
    return static_cast<ints>(c);
  }
};

template <typename S>
struct mtype_policy<S, S> {
  typedef S ints;
  typedef S intb;
  static ints add(ints a, ints b, ints mod) {
    a += b;
    if (a >= mod) a -= mod;
    return a;
  }
  static ints sub(ints a, ints b, ints mod) {
    a -= b;
    if (a < 0) a += mod;
    return a;
  }
  static ints mul(ints a, ints b, ints mod) {
    a = a * b % mod;
    return a;
  }
};

template <typename S>
struct mtype_policy<S, fake_int128> {
  typedef S ints;
  typedef fake_int128 intb;
  static ints add(ints a, ints b, ints mod) {
    a += b;
    if (a >= mod) a -= mod;
    return a;
  }
  static ints sub(ints a, ints b, ints mod) {
    a -= b;
    if (a < 0) a += mod;
    return a;
  }
  static ints mul(ints a, ints b, ints mod) { return mul_mod_ex(a, b, mod); }
};

template <typename S, typename B, S MOD>
struct NModNumber;

template <typename T, int64 MOD>
struct NModNumberL;

template <typename S, typename B>
struct NModNumberD;

template <typename T>
struct NModNumberDL;

template <typename S, typename B, S MOD>
ostream& operator<<(ostream& o, const NModNumber<S, B, MOD>& m);

template <typename T, int64 mod>
ostream& operator<<(ostream& o, const NModNumberL<T, mod>& m);

template <typename S, typename B>
ostream& operator<<(ostream& o, const NModNumberD<S, B>& m);

template <typename T>
ostream& operator<<(ostream& o, const NModNumberDL<T>& m);

template <typename S, typename B, S MOD>
struct NModNumber {
  typedef mtype_policy<S, B> MTI;
  typedef typename MTI::ints ints;
  typedef typename MTI::intb intb;

  static_assert(MOD > 0, "MOD > 0");

  NModNumber(ints val = 0) {
    if (val >= 0) {
      value_ = val >= MOD ? val % MOD : val;
    } else {
      value_ = val <= -MOD ? val % MOD + MOD : val + MOD;
    }
  }

  NModNumber(ints val, init_direct_t) : value_(val) {}

  NModNumber operator+(const NModNumber& y) const {
    return NModNumber(MTI::add(value_, y.value_, MOD), __init_direct);
  }

  NModNumber& operator+=(const NModNumber& y) {
    value_ = MTI::add(value_, y.value_, MOD);
    return *this;
  }

  NModNumber operator-(const NModNumber& y) const {
    return NModNumber(MTI::sub(value_, y.value_, MOD), __init_direct);
  }

  NModNumber& operator-=(const NModNumber& y) {
    value_ = MTI::sub(value_, y.value_, MOD);
    return *this;
  }

  NModNumber operator+() const { return NModNumber(value_, __init_direct); }

  NModNumber operator-() const {
    return NModNumber(MTI::sub(0, value_, MOD), __init_direct);
  }

  NModNumber operator*(const NModNumber& y) const {
    return NModNumber(MTI::mul(value_, y.value_, MOD), __init_direct);
  }

  NModNumber& operator*=(const NModNumber& y) {
    value_ = MTI::mul(value_, y.value_, MOD);
    return *this;
  }

  int operator<(const NModNumber& y) const { return value() < y.value(); }

  // operator ints () const {return value_;}
  ints value() const { return value_; }
  NModNumber& fix_value() { return *this; }
  friend ostream& operator<<<S, B, MOD>(ostream& o, const NModNumber& m);

  ints value_;
};

template <typename S, typename B, S MOD>
ostream& operator<<(ostream& o, const NModNumber<S, B, MOD>& m) {
  return o << m.value_;
}

template <int mod>
using NModNumber3232 = NModNumber<int, int, mod>;

template <int mod>
using NModNumber3264 = NModNumber<int, int64, mod>;

template <int64 mod>
using NModNumber6464 = NModNumber<int64, int64, mod>;

#if PE_HAS_INT128
template <int128 mod>
using NModNumber128128 = NModNumber<int128, int128, mod>;
template <int64 mod>
using NModNumber64128 = NModNumber<int64, int128, mod>;
#endif

template <typename T, int64 MOD>
struct NModNumberL {
  static_assert(MOD > 0, "MOD > 0");

  NModNumberL(T val = 0) : value_(val) {}

  NModNumberL operator+(const NModNumberL& y) const {
    return NModNumberL(value_ + y.value_);
  }

  NModNumberL& operator+=(const NModNumberL& y) {
    value_ += y.value_;
    return *this;
  }

  NModNumberL operator-(const NModNumberL& y) const {
    return NModNumberL(value_ - y.value_);
  }

  NModNumberL& operator-=(const NModNumberL& y) {
    value_ -= y.value_;
    return *this;
  }

  NModNumberL operator+() const { return NModNumberL(value_); }

  NModNumberL operator-() const { return NModNumberL(-value_); }

  NModNumberL operator*(const NModNumberL& y) const {
    return NModNumberL(value_ * y.value_);
  }

  NModNumberL& operator*=(const NModNumberL& y) {
    value_ = value_ * y.value_;
    return *this;
  }

  int operator<(const NModNumberL& y) const { return value_ < y.value_; }

  T value() const { return value_; }

  NModNumberL& fix_value() {
    value_ = regulate_mod(value_, MOD);
    return *this;
  }

  T value_;
};

template <typename T, int64 mod>
ostream& operator<<(ostream& o, const NModNumberL<T, mod>& m) {
  return o << m.value();
}

template <int64 mod>
using NModNumberL32 = NModNumberL<int, mod>;

template <int64 mod>
using NModNumberL64 = NModNumberL<int64, mod>;

#if PE_HAS_INT128
template <int64 mod>
using NModNumberL128 = NModNumberL<int128, mod>;
#endif

int64 DEFAULT_MOD = 1;

template <typename S, typename B>
struct NModNumberD {
  typedef mtype_policy<S, B> MTI;
  typedef typename MTI::ints ints;
  typedef typename MTI::intb intb;

  NModNumberD(ints val = 0) {
    if (val >= 0) {
      value_ = val >= DEFAULT_MOD ? val % DEFAULT_MOD : val;
    } else {
      value_ = val <= -DEFAULT_MOD ? val % DEFAULT_MOD + DEFAULT_MOD
                                   : val + DEFAULT_MOD;
    }
  }

  NModNumberD(ints val, init_direct_t) : value_(val) {}

  NModNumberD& operator=(ints v) {
    NModNumberD temp(v);
    value_ = temp.value_;
    return *this;
  }

  NModNumberD& operator=(const NModNumberD& other) {
    value_ = other.value_;
    return *this;
  }

  NModNumberD operator+(const NModNumberD& y) const {
    return NModNumberD(MTI::add(value_, y.value_, DEFAULT_MOD), __init_direct);
  }

  NModNumberD operator+(const ints y) const { return *this + NModNumberD(y); }

  NModNumberD& operator+=(const NModNumberD& y) {
    value_ = MTI::add(value_, y.value_, DEFAULT_MOD);
    return *this;
  }

  NModNumberD& operator+=(const ints y) { return *this += NModNumberD(y); }

  NModNumberD operator-(const NModNumberD& y) const {
    return NModNumberD(MTI::sub(value_, y.value_, DEFAULT_MOD), __init_direct);
  }

  NModNumberD operator-(const ints y) const { return *this - NModNumberD(y); }

  NModNumberD& operator-=(const NModNumberD& y) {
    value_ = MTI::sub(value_, y.value_, DEFAULT_MOD);
    return *this;
  }

  NModNumberD& operator-=(const ints y) { return *this -= NModNumberD(y); }

  NModNumberD operator+() const { return NModNumberD(value_, __init_direct); }

  NModNumberD operator-() const {
    return NModNumberD(MTI::sub(0, value_, DEFAULT_MOD), __init_direct);
  }

  NModNumberD operator*(const NModNumberD& y) const {
    return NModNumberD(MTI::mul(value_, y.value_, DEFAULT_MOD), __init_direct);
  }

  NModNumberD operator*(const ints y) const { return *this * NModNumberD(y); }

  NModNumberD& operator*=(const NModNumberD& y) {
    value_ = MTI::mul(value_, y.value_, DEFAULT_MOD);
    return *this;
  }

  NModNumberD& operator*=(const ints y) { return *this *= NModNumberD(y); }

  int operator<(const NModNumberD& y) const { return value_ < y.value_; }

  // operator ints () const {return value_;}
  ints value() const { return value_; }
  NModNumberD& fix_value() { return *this; }
  friend ostream& operator<<<S, B>(ostream& o, const NModNumberD& m);

  ints value_;
};

template <typename S, typename B>
ostream& operator<<(ostream& o, const NModNumberD<S, B>& m) {
  return o << m.value_;
}

using NModNumberD3232 = NModNumberD<int, int>;

using NModNumberD3264 = NModNumberD<int, int64>;

using NModNumberD6464 = NModNumberD<int64, int64>;

#if PE_HAS_INT128
using NModNumberD128128 = NModNumberD<int128, int128>;
using NModNumberD64128 = NModNumberD<int64, int128>;
#endif

template <typename T>
struct NModNumberDL {
  NModNumberDL(T val = 0) : value_(val) {}

  NModNumberDL& operator=(T v) {
    value_ = v;
    return *this;
  }

  NModNumberDL& operator=(const NModNumberDL& other) {
    value_ = other.value_;
    return *this;
  }

  NModNumberDL operator+(const NModNumberDL& y) const {
    return NModNumberDL(value_ + y.value_);
  }

  NModNumberDL operator+(const T y) const { return *this + NModNumberDL(y); }

  NModNumberDL& operator+=(const NModNumberDL& y) {
    value_ += y.value_;
    return *this;
  }

  NModNumberDL& operator+=(const T y) { return *this += NModNumberDL(y); }

  NModNumberDL operator-(const NModNumberDL& y) const {
    return NModNumberDL(value_ - y.value_);
  }

  NModNumberDL operator-(const T y) const { return *this - NModNumberDL(y); }

  NModNumberDL& operator-=(const NModNumberDL& y) {
    value_ -= y.value_;
    return *this;
  }

  NModNumberDL& operator-=(const T y) { return *this -= NModNumberDL(y); }

  NModNumberDL operator+() const { return NModNumberDL(value_); }

  NModNumberDL operator-() const { return NModNumberDL(-value_); }

  NModNumberDL operator*(const NModNumberDL& y) const {
    return NModNumberDL(value_ * y.value_);
  }

  NModNumberDL operator*(const T y) const { return *this * NModNumberDL(y); }

  NModNumberDL& operator*=(const NModNumberDL& y) {
    value_ *= y.value_;
    return *this;
  }

  NModNumberDL& operator*=(const T y) { return *this *= NModNumberDL(y); }

  int operator<(const NModNumberDL& y) const { return value_ < y.value_; }

  // operator ints () const {return value_;}
  T value() const { return value_; }
  NModNumberDL& fix_value() {
    value_ = regulate_mod(value_, DEFAULT_MOD);
    return *this;
  }
  friend ostream& operator<<<T>(ostream& o, const NModNumberDL& m);

  T value_;
};

template <typename T>
ostream& operator<<(ostream& o, const NModNumberDL<T>& m) {
  return o << m.value_;
}

using NModNumberDL32 = NModNumberDL<int>;

using NModNumberDL64 = NModNumberDL<int64>;

#if PE_HAS_INT128
using NModNumberDL128 = NModNumberDL<int128>;
#endif

template <int v>
struct NModNumberIndicator {
  enum { value = v };
};

template <typename X>
struct IsNModNumber {
  static constexpr NModNumberIndicator<0> NModNumberMatch(...);

  template <typename S, typename B, S mod>
  static constexpr NModNumberIndicator<1> NModNumberMatch(
      NModNumber<S, B, mod>);

  template <typename T, int64 mod>
  static constexpr NModNumberIndicator<1> NModNumberMatch(
      const NModNumberL<T, mod>&);

  static X makeX();

  typedef decltype(NModNumberMatch(makeX())) result_type;

  enum { result = result_type::value };
};

template <int v>
struct NModNumberDIndicator {
  enum { value = v };
};

template <typename X>
struct IsNModNumberD {
  static constexpr NModNumberDIndicator<0> NModNumberDMatch(...);

  template <typename S, typename B>
  static constexpr NModNumberDIndicator<1> NModNumberDMatch(NModNumberD<S, B>);

  template <typename T>
  static constexpr NModNumberDIndicator<1> NModNumberDMatch(
      const NModNumberDL<T>&);

  static X makeX();

  typedef decltype(NModNumberDMatch(makeX())) result_type;

  enum { result = result_type::value };
};

template <int v>
struct NModNumberOrNModNumberDIndicator {
  enum { value = v };
};
#endif
