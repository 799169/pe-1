#ifndef __PE_MOD__
#define __PE_MOD__

#include "pe_base"
#include "pe_integer_util"

// Modular arithmetic
template<typename T, typename M>
SL
REQUIRES((
  is_native_integer<T>::value &&
  is_native_integer<M>::value &&
  std::is_signed<T>::value))
RETURN(T)
regulate_mod(T a, M mod) {
  PE_ASSERT(mod >= 1);
  if (a >= 0) {
    if (a >= mod) a %= mod;
  } else {
    if (-a >= mod)
      a = a % mod + mod;
    else
      a += mod;
  }
  return a;
}

template<typename T, typename M>
SL
REQUIRES((
  is_native_integer<T>::value &&
  is_native_integer<M>::value &&
  std::is_unsigned<T>::value))
RETURN(T)
regulate_mod(T a, M mod) {
  PE_ASSERT(mod >= 1);
  if (a >= mod) a %= mod;
  return a;
}

template<typename T>
SL
REQUIRES((is_native_integer<T>::value))
RETURN(T)
regulate_mod(T a, T mod) {
  return regulate_mod<T, T>(a, mod);
}

template<typename T, typename M>
SL
REQUIRES((
  is_native_integer<T>::value &&
  is_native_integer<M>::value))
RETURN(T)
add_mod_impl(T a, T b, M mod) {
  a += b;
  if (a >= mod) a -= mod;
  return a;
}

template<typename T1, typename T2, typename M>
SL auto add_mod(T1 a, T2 b, M mod) ->
REQUIRES((
  is_native_integer<T1>::value &&
  is_native_integer<T2>::value &&
  is_native_integer<M>::value))
RETURN(typename BigIntegerType<T1, T2>::type) {
  typedef typename BigIntegerType<T1, T2>::type T;
  return add_mod_impl<T, M>(a, b, mod);
}

template<typename T, typename M>
SL
REQUIRES((
  is_native_integer<T>::value &&
  is_native_integer<M>::value))
RETURN(T)
sub_mod_impl(T a, T b, M mod) {
  return a >= b ? a - b : mod - b + a;
}

template<typename T1, typename T2, typename M>
SL auto sub_mod(T1 a, T2 b, M mod) -> 
REQUIRES((
  is_native_integer<T1>::value &&
  is_native_integer<T2>::value &&
  is_native_integer<M>::value))
RETURN(typename BigIntegerType<T1, T2>::type) {
  typedef typename BigIntegerType<T1, T2>::type T;
  return sub_mod_impl<T, M>(a, b, mod);
}

template<typename T, typename M>
SL
REQUIRES((
  is_native_integer<T>::value &&
  is_native_integer<M>::value))
RETURN(T)
mul_mod_impl(T a, T b, M mod) {
  return a * b % mod;
}

template<typename T1, typename T2, typename M>
SL auto mul_mod(T1 a, T2 b, M mod) ->
REQUIRES((
  is_native_integer<T1>::value &&
  is_native_integer<T2>::value &&
  is_native_integer<M>::value))
RETURN(typename BigIntegerType<T1, T2>::type) {
  typedef typename BigIntegerType<T1, T2>::type T;
  typedef typename BigIntegerType<int64, T>::type atLeastInt64T;
  return mul_mod_impl<atLeastInt64T, M>(a, b, mod);
}

// It's expected that all elements in b are prime.
// The behavior is undefined if it's not satisified.
template<typename T, typename M>
SL
REQUIRES((
  is_native_integer<T>::value &&
  is_native_integer<M>::value))
RETURN(T)
frac_mod_impl(std::vector<T> a, std::vector<T> b, M mod) {
  T ret = 1;
  const int size = b.size();
  int remain = size;
  for (auto iter: a) {
    for (int i = 0; remain > 0 && i < size; ++i) if (b[i] != 1 && (iter % b[i] == 0)) {
      iter /= b[i];
      b[i] = 1;
      --remain;
    }
    ret = mul_mod(ret, iter%mod, mod);
  }
  return ret;
}

template<typename T1, typename T2 = T1, typename M>
SL auto frac_mod(std::vector<T1> a, std::vector<T2> b, M mod) ->
REQUIRES((
  is_native_integer<T1>::value &&
  is_native_integer<T2>::value &&
  is_native_integer<M>::value))
RETURN(typename BigIntegerType<T1, T2>::type) {
  typedef typename BigIntegerType<T1, T2>::type T;
  typedef typename BigIntegerType<int64, T>::type atLeastInt64T;
  return frac_mod_impl<atLeastInt64T, M>(a, b, mod);
}

template<typename T1, typename T2, typename M>
SL T1 power_mod_impl(T1 x, T2 n, M mod) {
  if (mod == 1) return 0;

  T1 ret = 1;
  x %= mod;
  if (x < 0) x += mod;
  for (; n; n >>= 1) {
    if (n & 1) ret = ret * x % mod;
    x = x * x % mod;
  }
  return ret;
}

template<typename T1, typename T2, typename M>
SL T1 power_mod(T1 x, T2 n, M mod) {
  typedef typename BigIntegerType<int64, T1>::type atLeastInt64T1;
  return power_mod_impl<atLeastInt64T1, T2, M>(x, n, mod);
}

SL int64 mul_mod_ex(int64 a, int64 b, int64 mod) {
#if PE_HAS_INT128
  return (int128)a * b % mod;
#else
  int64 ret = 0;
  int64 flag = b;
  for (int64 d = 1; d <= a; d <<= 1) {
    if (d & a) {
      ret = (ret + flag) % mod;
    }
    flag = (flag << 1) % mod;
  }
  return ret;
#endif
}

SL int64 power_mod_ex(int64 x, int64 n, int64 mod) {
  if (mod == 1) return 0;

#if PE_HAS_INT128
  int64 ret = 1;
  x %= mod;
  if (x < 0) x += mod;
  for (; n; n >>= 1) {
    if (n & 1) ret = (int128)ret * x % mod;
    x = (int128)x * x % mod;
  }
  return ret;
#else
  int64 ret = 1;
  x %= mod;
  if (x < 0) x += mod;
  for (; n; n >>= 1) {
    if (n & 1) ret = mul_mod_ex(x, ret, mod);
    x = mul_mod_ex(x, x, mod);
  }
  return ret;
#endif
}

struct init_direct_t {};
static const init_direct_t __init_direct{};
struct fake_int128 {};

template <typename S, typename B>
struct mtype_policy {
  typedef S ints;
  typedef B intb;
  static ints add(ints a, ints b, ints mod) {
    intb c = (intb)a + b;
    if (c >= mod) c -= mod;
    return static_cast<ints>(c);
  }
  static ints sub(ints a, ints b, ints mod) {
    intb c = (intb)a - b;
    if (c < 0) c += mod;
    return static_cast<ints>(c);
  }
  static ints mul(ints a, ints b, ints mod) {
    intb c = (intb)a * b % mod;
    return static_cast<ints>(c);
  }
};

template <typename S>
struct mtype_policy<S, S> {
  typedef S ints;
  typedef S intb;
  static ints add(ints a, ints b, ints mod) {
    a += b;
    if (a >= mod) a -= mod;
    return a;
  }
  static ints sub(ints a, ints b, ints mod) {
    a -= b;
    if (a < 0) a += mod;
    return a;
  }
  static ints mul(ints a, ints b, ints mod) {
    a = a * b % mod;
    return a;
  }
};

template <typename S>
struct mtype_policy<S, fake_int128> {
  typedef S ints;
  typedef fake_int128 intb;
  static ints add(ints a, ints b, ints mod) {
    a += b;
    if (a >= mod) a -= mod;
    return a;
  }
  static ints sub(ints a, ints b, ints mod) {
    a -= b;
    if (a < 0) a += mod;
    return a;
  }
  static ints mul(ints a, ints b, ints mod) { return mul_mod_ex(a, b, mod); }
};

template <typename S, typename B, S MOD>
struct mint;

template <typename T, int64 MOD>
struct mintl;

template <typename S, typename B>
struct mintd;

template <typename T>
struct mintdl;

template <typename S, typename B, S MOD>
ostream& operator<<(ostream& o, const mint<S, B, MOD>& m);

template <typename T, int64 mod>
ostream& operator<<(ostream& o, const mintl<T, mod>& m);

template <typename S, typename B>
ostream& operator<<(ostream& o, const mintd<S, B>& m);

template <typename T>
ostream& operator<<(ostream& o, const mintdl<T>& m);

template <typename S, typename B, S MOD>
struct mint {
  typedef mtype_policy<S, B> MTI;
  typedef typename MTI::ints ints;
  typedef typename MTI::intb intb;

  static_assert(MOD > 0, "MOD > 0");

  mint(ints val = 0) {
    if (val >= 0) {
      value_ = val >= MOD ? val % MOD : val;
    } else {
      value_ = val <= -MOD ? val % MOD + MOD : val + MOD;
    }
  }

  mint(ints val, init_direct_t) : value_(val) {}

  mint operator+(const mint& y) const {
    return mint(MTI::add(value_, y.value_, MOD), __init_direct);
  }

  mint& operator+=(const mint& y) {
    value_ = MTI::add(value_, y.value_, MOD);
    return *this;
  }

  mint operator-(const mint& y) const {
    return mint(MTI::sub(value_, y.value_, MOD), __init_direct);
  }

  mint& operator-=(const mint& y) {
    value_ = MTI::sub(value_, y.value_, MOD);
    return *this;
  }

  mint operator*(const mint& y) const {
    return mint(MTI::mul(value_, y.value_, MOD), __init_direct);
  }

  mint& operator*=(const mint& y) {
    value_ = MTI::mul(value_, y.value_, MOD);
    return *this;
  }

  int operator<(const mint& y) const { return value() < y.value(); }

  // operator ints () const {return value_;}
  ints value() const { return value_; }
  mint& fix_value() { return *this; }
  friend ostream& operator<<<S, B, MOD>(ostream& o, const mint& m);

  ints value_;
};

template <typename S, typename B, S MOD>
ostream& operator<<(ostream& o, const mint<S, B, MOD>& m) {
  return o << m.value_;
}

template <int32_t mod>
using mint3232 = mint<int32_t, int32_t, mod>;

template <int32_t mod>
using mint3264 = mint<int32_t, int64_t, mod>;

template <int64_t mod>
using mint6464 = mint<int64_t, int64_t, mod>;

#if PE_HAS_INT128
template <int128 mod>
using mint128128 = mint<int128, int128, mod>;
template <int64_t mod>
using mint64128 = mint<int64_t, int128, mod>;
#endif

template <typename T, int64 MOD>
struct mintl {
  static_assert(MOD > 0, "MOD > 0");

  mintl(T val = 0): value_(val) {}

  mintl operator+(const mintl& y) const { return mintl(value_ + y.value_); }

  mintl& operator+=(const mintl& y) {
    value_ += y.value_;
    return *this;
  }

  mintl operator-(const mintl& y) const { return mintl(value_ - y.value_); }

  mintl& operator-=(const mintl& y) {
    value_ -= y.value_;
    return *this;
  }

  mintl operator*(const mintl& y) const { return mintl(value_ * y.value_); }

  mintl& operator*=(const mintl& y) {
    value_ = value_ * y.value_;
    return *this;
  }

  int operator<(const mintl& y) const { return value_ < y.value_; }

  T value() const { return value_; }

  mintl& fix_value() {
    value_ = regulate_mod(value_, MOD);
    return *this;
  }

  T value_;
};

template <typename T, int64 mod>
ostream& operator<<(ostream& o, const mintl<T, mod>& m) {
  return o << m.value();
}

template <int64 mod>
using mintl32 = mintl<int32_t, mod>;

template <int64 mod>
using mintl64 = mintl<int64, mod>;

#if PE_HAS_INT128
template <int64 mod>
using mintl128 = mintl<int128, mod>;
#endif

int64 GMOD = 1;

template <typename S, typename B>
struct mintd {
  typedef mtype_policy<S, B> MTI;
  typedef typename MTI::ints ints;
  typedef typename MTI::intb intb;

  mintd(ints val = 0) {
    if (val >= 0) {
      value_ = val >= GMOD ? val % GMOD : val;
    } else {
      value_ = val <= -GMOD ? val % GMOD + GMOD : val + GMOD;
    }
  }

  mintd(ints val, init_direct_t) : value_(val) {}

  mintd& operator=(ints v) {
    mintd temp(v);
    value_ = temp.value_;
    return *this;
  }

  mintd& operator=(const mintd& other) {
    value_ = other.value_;
    return *this;
  }

  mintd operator+(const mintd& y) const {
    return mintd(MTI::add(value_, y.value_, GMOD), __init_direct);
  }

  mintd operator+(const ints y) const { return *this + mintd(y); }

  mintd& operator+=(const mintd& y) {
    value_ = MTI::add(value_, y.value_, GMOD);
    return *this;
  }

  mintd& operator+=(const ints y) { return *this += mintd(y); }

  mintd operator-(const mintd& y) const {
    return mintd(MTI::sub(value_, y.value_, GMOD), __init_direct);
  }

  mintd operator-(const ints y) const { return *this - mintd(y); }

  mintd& operator-=(const mintd& y) {
    value_ = MTI::sub(value_, y.value_, GMOD);
    return *this;
  }

  mintd& operator-=(const ints y) { return *this -= mintd(y); }

  mintd operator*(const mintd& y) const {
    return mintd(MTI::mul(value_, y.value_, GMOD), __init_direct);
  }

  mintd operator*(const ints y) const { return *this * mintd(y); }

  mintd& operator*=(const mintd& y) {
    value_ = MTI::mul(value_, y.value_, GMOD);
    return *this;
  }

  mintd& operator*=(const ints y) { return *this *= mintd(y); }

  int operator<(const mintd& y) const { return value_ < y.value_; }

  // operator ints () const {return value_;}
  ints value() const { return value_; }
  mintd& fix_value() { return *this; }
  friend ostream& operator<<<S, B>(ostream& o, const mintd& m);

  ints value_;
};

template <typename S, typename B>
ostream& operator<<(ostream& o, const mintd<S, B>& m) {
  return o << m.value_;
}

using mintd3232 = mintd<int32_t, int32_t>;

using mintd3264 = mintd<int32_t, int64_t>;

using mintd6464 = mintd<int64_t, int64_t>;

#if PE_HAS_INT128
using mintd128128 = mintd<int128, int128>;
using mintd64128 = mintd<int64_t, int128>;
#endif

template <typename T>
struct mintdl {
  mintdl(T val = 0): value_(val) {}

  mintdl& operator=(T v) {
    value_ = v;
    return *this;
  }

  mintdl& operator=(const mintdl& other) {
    value_ = other.value_;
    return *this;
  }

  mintdl operator+(const mintdl& y) const {
    return mintdl(value_ + y.value_);
  }

  mintdl operator+(const T y) const { return *this + mintdl(y); }

  mintdl& operator+=(const mintdl& y) {
    value_ += y.value_;
    return *this;
  }

  mintdl& operator+=(const T y) { return *this += mintdl(y); }

  mintdl operator-(const mintdl& y) const {
    return mintdl(value_ - y.value_);
  }

  mintdl operator-(const T y) const { return *this - mintdl(y); }

  mintdl& operator-=(const mintdl& y) {
    value_ -= y.value_;
    return *this;
  }

  mintdl& operator-=(const T y) { return *this -= mintdl(y); }

  mintdl operator*(const mintdl& y) const {
    return mintdl(value_ * y.value_);
  }

  mintdl operator*(const T y) const { return *this * mintdl(y); }

  mintdl& operator*=(const mintdl& y) {
    value_ *= y.value_;
    return *this;
  }

  mintdl& operator*=(const T y) { return *this *= mintdl(y); }

  int operator<(const mintdl& y) const { return value_ < y.value_; }

  // operator ints () const {return value_;}
  T value() const { return value_; }
  mintdl& fix_value() {
    value_ = regulate_mod(value_, GMOD);
    return *this;
  }
  friend ostream& operator<<<T>(ostream& o, const mintdl& m);

  T value_;
};

template <typename T>
ostream& operator<<(ostream& o, const mintdl<T>& m) {
  return o << m.value_;
}

using mintdl32 = mintdl<int32_t>;

using mintdl64 = mintdl<int64>;

#if PE_HAS_INT128
using mintdl128 = mintdl<int128>;
#endif

template <int v>
struct mint_indicator {
  enum { value = v };
};

template <typename X>
struct is_mint {
  static constexpr mint_indicator<0> mint_match(...);

  template <typename S, typename B, S mod>
  static constexpr mint_indicator<1> mint_match(mint<S, B, mod>);

  template <typename T, int64 mod>
  static constexpr mint_indicator<1> mint_match(const mintl<T, mod>&);

  static X makeX();

  typedef decltype(mint_match(makeX())) result_type;

  enum { result = result_type::value };
};

template <int v>
struct mintd_indicator {
  enum { value = v };
};

template <typename X>
struct is_mintd {
  static constexpr mintd_indicator<0> mintd_match(...);

  template <typename S, typename B>
  static constexpr mintd_indicator<1> mintd_match(mintd<S, B>);

  template <typename T>
  static constexpr mintd_indicator<1> mintd_match(const mintdl<T>&);

  static X makeX();

  typedef decltype(mintd_match(makeX())) result_type;

  enum { result = result_type::value };
};

template <int v>
struct mint_or_mintd_indicator {
  enum { value = v };
};
#endif
