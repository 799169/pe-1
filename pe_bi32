#ifndef __PE_BI_H__
#define __PE_BI_H__

#include "pe_base"
#include "pe_fraction"
#include "pe_int128"
#include "pe_nt"
#include "pe_ntt"
#include "pe_type_traits"

static const struct alloc_mem {
} alloc_mem_tag;

static const struct zero_initialize {
} zero_initialize_tag;

// Predefined allocator
struct bi_allocator_std {
  static unsigned int* allocate(int& length) {
    length = ((length + 3) >> 2) << 2;
    return new unsigned int[length];
  }
  static void deallocate(unsigned int* data) { delete[] data; }
};

template <int SIZE>
struct bi_allocator_fixed_size_impl {
  vector<unsigned int*> available;
  int top;

  bi_allocator_fixed_size_impl() { top = 0; }

  unsigned int* allocate(int& length) {
    if (length > SIZE) {
      dbg(length);
    }
    PE_ASSERT(length <= SIZE);
    length = SIZE;
    if (top == available.size()) {
      available.push_back(new unsigned int[SIZE]);
    }
    return available[top++];
  }

  void deallocate(unsigned int* ptr) { available[--top] = ptr; }
};

static bi_allocator_fixed_size_impl<1 << 16> allocator_16;
static bi_allocator_fixed_size_impl<1 << 20> allocator_20;

static auto& allocator_impl = allocator_16;

struct bi_allocator_fixed_size {
  static unsigned int* allocate(int& length) {
    return allocator_impl.allocate(length);
  }
  static void deallocate(unsigned int* data) {
    allocator_impl.deallocate(data);
  }
};

// Configuration of BigInteger.
typedef bi_allocator_std bi_allocator;

class BigInteger {
  static const unsigned int max_32bit_value = 0xFFFFFFFF;
  static const uint64 bit32_value = 1ull << 32;
  static const unsigned int output_mod = 1000000000;
  static const unsigned int output_mod_dig = 9;

  static const unsigned int div32_bit = 5;
  static const unsigned int mod32_mask = 31;

 public:
  // constructors, destructors, value semantics.
  BigInteger() : BigInteger(zero_initialize_tag) {
    reserve(1);
    data_[0] = 0;
    sign_ = 0;
  }

  ~BigInteger() {
    if (data_) {
      bi_allocator::deallocate(data_);
    }
  }

  BigInteger(const BigInteger& other) : BigInteger(zero_initialize_tag) {
    reserve(other.bufferLength_);
    sign_ = other.sign_;
    pos_ = other.pos_;
    copy(other.data_, other.data_ + other.pos_ + 1, data_);
  }

  BigInteger(BigInteger&& other) : BigInteger(zero_initialize_tag) {
    std::swap(data_, other.data_);
    std::swap(bufferLength_, other.bufferLength_);
    std::swap(sign_, other.sign_);
    std::swap(pos_, other.pos_);
  }

  BigInteger& operator=(const BigInteger& other) {
    return *this = BigInteger(other);
  }

  BigInteger& operator=(BigInteger&& other) {
    std::swap(data_, other.data_);
    std::swap(bufferLength_, other.bufferLength_);
    std::swap(sign_, other.sign_);
    std::swap(pos_, other.pos_);
    return *this;
  }

  template <typename T,
            typename TT = REQUIRES((is_native_integer<T>::value)) RETURN(T)>
  BigInteger(T value) : BigInteger(zero_initialize_tag) {
    if (value == 0) {
      reserve(1);
      data_[0] = 0;
      sign_ = 0;
      return;
    }

    typedef typename std::make_unsigned<T>::type unsignedT;
    unsignedT absValue = getAbsValue(value);
    if (sizeof(T) <= 8) {
      resetAbs(absValue);
    } else {
      int need = 0;
      for (auto t = absValue; t > 0; ++need, t >>= 32)
        ;
      reserve(need);

      pos_ = -1;
      for (auto t = absValue; t > 0;
           data_[++pos_] = t & max_32bit_value, t >>= 32)
        ;
    }
    sign_ = value > 0 ? 1 : -1;
  }

  template <typename T>
  SL REQUIRES((is_native_integer<T>::value && is_signed<T>::value)) RETURN(T)
      getAbsValue(T x) {
    return x >= 0 ? x : -x;
  }

  template <typename T>
  SL REQUIRES((is_native_integer<T>::value && is_unsigned<T>::value)) RETURN(T)
      getAbsValue(T x) {
    return x;
  }

  template <typename T,
            typename TT = REQUIRES((is_native_integer<T>::value)) RETURN(T)>
  BigInteger& operator=(T value) {
    return *this = BigInteger(value);
  }

  BigInteger(const string& str) : BigInteger(zero_initialize_tag) {
    const int n = (int)str.size();
    if (n == 0) {
      reserve(1);
      data_[0] = 0;
      sign_ = 0;
      return;
    }
    std::vector<unsigned int> value(n);
    for (int i = 0, j = n - 1; i < n; ++i, --j) {
      value[j] = str[i] - '0';
    }

    int now = n - 1;
    while (now > 0 && value[now] == 0) --now;

    std::vector<unsigned int> result;
    do {
      uint64 add = 0;
      for (int i = now; i > 0; --i) {
        const uint64 x = add + value[i];
        const uint64 next_add = (x & max_32bit_value) * 10;
        value[i] = x >> 32;
        add = next_add;
      }
      uint64 x = add + value[0];
      value[0] = x >> 32;
      result.push_back(x & max_32bit_value);
      while (now > 0 && value[now] == 0) --now;
    } while (now > 0 || value[now] > 0);

    reserve((int)result.size());

    sign_ = 1;
    pos_ = max(0, (int)result.size() - 1);
    copy(result.begin(), result.end(), data_);
    fixPos();
  }

  template <typename T,
            typename TT = REQUIRES((is_native_integer<T>::value)) RETURN(T)>
  BigInteger(const vector<T>& v) : BigInteger(zero_initialize_tag) {
    if (v.empty()) {
      reserve(1);
      data_[0] = 0;
      sign_ = 0;
      return;
    }

    const unsigned int n = (unsigned int)v.size();
    unsigned int need = (n + 31) >> 5;
    reserve(need);

    unsigned int value = 0;
    unsigned int flag = 1;
    for (unsigned i = 0; i < n; ++i) {
      if (v[i]) {
        value |= flag;
      }
      flag <<= 1;
      if (((i + 1) & mod32_mask) == 0) {
        data_[pos_++] = value;
        value = 0;
        flag = 1;
      }
    }
    if (n & mod32_mask) {
      data_[pos_++] = value;
    }
    --pos_;
    sign_ = 1;
    fixPos();
  }

 private:
  // Internal constructor
  BigInteger(int size, alloc_mem) : BigInteger(zero_initialize_tag) {
    reserve(size);
    data_[0] = 0;
    sign_ = 0;
  }

  BigInteger(const BigInteger& other, int minBuffer)
      : BigInteger(zero_initialize_tag) {
    reserve(max(other.bufferLength_, minBuffer));
    sign_ = other.sign_;
    pos_ = other.pos_;
    copy(other.data_, other.data_ + other.pos_ + 1, data_);
  }

  BigInteger(zero_initialize)
      : data_(nullptr), bufferLength_(0), sign_(0), pos_(0) {}

 private:
  void resetAbs(uint64 v) {
    if (v <= max_32bit_value) {
      reserve(1);
      data_[0] = (unsigned)v;
      pos_ = 0;
    } else {
      reserve(2);
      data_[0] = v & max_32bit_value;
      data_[1] = v >> 32;
      pos_ = 1;
    }
  }

 public:
  // compare operators
  friend inline int operator>(const BigInteger& l, const BigInteger& r);
  friend inline int operator<(const BigInteger& l, const BigInteger& r);
  friend inline int operator==(const BigInteger& l, const BigInteger& r);
  friend inline int operator>=(const BigInteger& l, const BigInteger& r);
  friend inline int operator<=(const BigInteger& l, const BigInteger& r);
  friend inline int operator!=(const BigInteger& l, const BigInteger& r);

  // binary operators
  friend inline BigInteger operator+(const BigInteger& l, const BigInteger& r);
  friend inline BigInteger operator-(const BigInteger& l, const BigInteger& r);

  friend inline BigInteger operator*(const BigInteger& l, const BigInteger& r);

  template <typename T>
  friend inline REQUIRES(
      (is_native_integer<T>::value &&
       !is_same<typename remove_cvref<T>::type, BigInteger>::value))
      RETURN(BigInteger)
      operator*(const BigInteger& l, T r);

  template <typename T>
  friend inline REQUIRES(
      (is_native_integer<T>::value &&
       !is_same<typename remove_cvref<T>::type, BigInteger>::value))
      RETURN(BigInteger)
      operator*(T l, const BigInteger& r);

  friend inline BigInteger operator/(const BigInteger& l, const BigInteger& r);

  template <typename T>
  friend inline REQUIRES(
      (is_native_integer<T>::value &&
       !is_same<typename remove_cvref<T>::type, BigInteger>::value))
      RETURN(BigInteger)
      operator/(const BigInteger& l, T r);

  friend inline tuple<BigInteger, BigInteger> div(const BigInteger& l,
                                                  const BigInteger& r);

  template <typename T>
  friend inline REQUIRES(
      (is_native_integer<T>::value &&
       !is_same<typename remove_cvref<T>::type, BigInteger>::value))
      RETURN(tuple<BigInteger, T>) div(const BigInteger& l, T r);

  template <typename T>
  friend inline REQUIRES(
      (is_native_integer<T>::value &&
       !is_same<typename remove_cvref<T>::type, BigInteger>::value))
      RETURN(void) divInplace(BigInteger& l, T r, T& remain);

  friend inline BigInteger operator%(const BigInteger& l, const BigInteger& r);

  template <typename T>
  friend inline REQUIRES(
      (is_native_integer<T>::value &&
       !is_same<typename remove_cvref<T>::type, BigInteger>::value)) RETURN(T)
  operator%(const BigInteger& l, T r);

  friend inline BigInteger operator&(const BigInteger& l, const BigInteger& r);
  friend inline BigInteger operator^(const BigInteger& l, const BigInteger& r);
  friend inline BigInteger operator|(const BigInteger& l, const BigInteger& r);

  template <typename T>
  friend inline REQUIRES(
      (is_native_integer<T>::value &&
       !is_same<typename remove_cvref<T>::type, BigInteger>::value))
      RETURN(BigInteger)
      operator<<(const BigInteger& l, T n);

  template <typename T>
  friend inline REQUIRES(
      (is_native_integer<T>::value &&
       !is_same<typename remove_cvref<T>::type, BigInteger>::value))
      RETURN(BigInteger)
      operator>>(const BigInteger& l, T n);

 public:
  // unary operations
  BigInteger operator-() const {
    BigInteger ret(*this);
    ret.sign_ = -ret.sign_;
    return ret;
  }

  const BigInteger& operator+() const { return *this; }

  BigInteger operator~() const {
    BigInteger ret(*this);
    for (int i = 0; i < ret.pos_; ++i) ret[i] ^= max_32bit_value;
    unsigned int y = ret[ret.pos_];
    for (unsigned int x = 1; y; ret[ret.pos_] ^= x, x <<= 1, y >>= 1)
      ;

    ret.fixPos();

    return ret;
  }

 private:
  static int absCompare(const BigInteger& l, const BigInteger& r) {
    if (l.size() <= 2 && r.size() <= 2) {
      const uint64 a = l.toInt<uint64>();
      const uint64 b = r.toInt<uint64>();
      if (a == b) return 0;
      return a > b ? 1 : -1;
    }

    int posL = l.pos_;
    int posR = r.pos_;

    if (posL != posR) {
      return posL > posR ? 1 : -1;
    }

    for (; posL >= 0 && l[posL] == r[posL]; --posL)
      ;

    return posL >= 0 ? (l[posL] > r[posL] ? 1 : -1) : 0;
  }

  static BigInteger absAdd(const BigInteger& l, const BigInteger& r) {
    BigInteger ret(l, max(l.size(), r.size()) + 1);
    absAddInplace(ret, r);
    return ret;
  }

  static void absAddInplace(BigInteger& l, const BigInteger& r) {
    if (l.size() <= 2 && r.size() <= 1 || l.size() <= 1 && r.size() <= 2) {
      l.resetAbs(l.toInt<uint64>() + r.toInt<uint64>());
      return;
    }

    l.reserve(l.size() + r.size() + 1);

    const int maxPos = max(l.pos_, r.pos_);
    const int minPos = min(l.pos_, r.pos_);

    int idx = 0;
    unsigned int inc = 0;

    while (idx <= minPos) {
      uint64 t = (uint64)l[idx] + r[idx] + inc;
      l[idx++] = t & max_32bit_value;
      inc = t >> 32;
    }

    const auto* largeData = l.pos_ > r.pos_ ? l.data_ : r.data_;
    while (idx <= maxPos) {
      uint64 t = (uint64)largeData[idx] + inc;
      l[idx++] = t & max_32bit_value;
      inc = t >> 32;
    }

    if (inc) {
      l[idx++] = inc;
    }

    l.pos_ = max(idx - 1, 0);
    l.fixPos();
  }

  static BigInteger absSub(const BigInteger& l, const BigInteger& r) {
    BigInteger ret(l);
    absSubInplace(ret, r);
    return ret;
  }

  static void absSubInplace(BigInteger& l, const BigInteger& r) {
    PE_ASSERT(BigInteger::absCompare(l, r) >= 0);

    if (l.size() <= 2 && r.size() <= 2) {
      l.resetAbs(l.toInt<uint64>() - r.toInt<uint64>());
      return;
    }

    int maxPos = l.pos_;
    int minPos = r.pos_;

    unsigned int borrow = 0;
    for (int curr = 0; curr <= minPos; ++curr) {
      unsigned int nextBorrow = 0;
      uint64 t = l[curr];
      while (t < (uint64)r[curr] + borrow) {
        nextBorrow++;
        t += bit32_value;
      }
      l[curr] = (unsigned)(t - r[curr] - borrow);
      borrow = nextBorrow;
    }
    for (int curr = minPos + 1; curr <= maxPos; ++curr) {
      unsigned int nextBorrow = 0;
      uint64 t = l[curr];
      while (t < borrow) {
        nextBorrow++;
        t += bit32_value;
      }
      l[curr] = (unsigned)(t - borrow);
      borrow = nextBorrow;
    }
    l.fixPos();
  }

#if HAS_POLY_MUL_NTT32_SMALL
  static BigInteger absMulNtt(const BigInteger& l, const BigInteger& r) {
    const int n = l.size() << 1;
    const int m = r.size() << 1;

    std::vector<uint64> X(n), Y(m);

    for (int i = 0; i <= l.pos_; ++i) {
      X[i << 1] = l[i] & 65535u;
      X[(i << 1) + 1] = l[i] >> 16;
    }
    for (int i = 0; i <= r.pos_; ++i) {
      Y[i << 1] = r[i] & 65535;
      Y[(i << 1) + 1] = r[i] >> 16;
    }
    const int allocateSize = n + m + 8;
    const int resultSize = n + m - 1;
    auto result = ntt32::poly_mul_ntt_small(X, Y, 0);
    result.resize(allocateSize);
    uint64 inc = 0;
    for (int i = 0; i < resultSize; ++i) {
      uint64 t = inc + result[i];
      result[i] = t & 65535u;
      inc = t >> 16;
    }
    int now = resultSize;
    while (inc > 0) {
      result[now++] = inc & 65535u;
      inc >>= 16;
    }
    if (now & 1) {
      result[now++] = 0;
    }

    BigInteger ret(now >> 1, alloc_mem_tag);
    for (int i = 0; i < now; i += 2) {
      ret[i >> 1] = (unsigned)((result[i + 1] << 16) | result[i]);
    }
    ret.pos_ = (now >> 1) - 1;
    ret.sign_ = 1;
    ret.fixPos();
    return ret;
  }
#endif

  static BigInteger absMul(const BigInteger& l, const BigInteger& r) {
    if (l.size() <= 1 && r.size() <= 1) {
      return (uint64)l[0] * r[0];
    }
    if (r.size() <= 1) {
      return absMul(l, r.toInt<uint64>());
    }
    if (l.size() <= 1) {
      return absMul(r, l.toInt<uint64>());
    }

#if HAS_POLY_MUL_NTT32_SMALL
    {
      // If the cost of ntt is less than normal multiplication, then use ntt.
      const uint64 cost1 = (uint64)l.size() * r.size();
      const uint64 len = (l.size() + r.size()) << 1;
      int64 alignedLen = 1;
      int bit = 1;
      while (alignedLen < (int64)len) alignedLen <<= 1, ++bit;
      const uint64 cost2 = alignedLen * bit * 3;

      if (cost2 * 2 < cost1) {
        return absMulNtt(l, r);
      }
    }
#endif

    const int posL = l.pos_;
    const int posR = r.pos_;

    const int newSize = l.size() + r.size() + 1;

    BigInteger ret(newSize, alloc_mem_tag);
    fill(ret.data_, ret.data_ + newSize, 0);

    for (int i = 0; i <= posR; ++i) {
      auto t = r[i];
      uint64 inc = 0;
      int j = 0;
      for (; j <= posL; ++j) {
        inc += (uint64)t * l[j] + ret[i + j];
        ret[i + j] = inc & max_32bit_value;
        inc >>= 32;
      }
      for (; inc; inc >>= 32) {
        ret[i + j++] = inc & max_32bit_value;
      }
    }
    ret.pos_ = posL + posR + 2;
    ret.fixPos();
    return ret;
  }

  template <typename T>
  static BigInteger absMul(const BigInteger& l, T r) {
    static_assert(is_unsigned<T>::value, "T must be unsigned");
    if (r > max_32bit_value) {
      return absMul(l, BigInteger(r));
    }
    BigInteger ret(l, l.size() + BigInteger(r).size() + 1);
    absMulInplace(ret, r);
    return ret;
  }

  template <typename T>
  static void absMulInplace(BigInteger& l, T r) {
    static_assert(is_unsigned<T>::value, "T must be unsigned");
    if (r > max_32bit_value) {
      l = absMul(l, BigInteger(r));
      return;
    }

    if (l.size() <= 1) {
      l.resetAbs((uint64)l[0] * r);
      return;
    }

    l.reserve(l.size() + BigInteger(r).size() + 1);

    uint64 inc = 0;
    int top = 0;
    for (int i = 0; i <= l.pos_; ++i) {
      uint64 v = (uint64)l[i] * r + inc;
      l[top++] = v & max_32bit_value;
      inc = v >> 32;
    }

    while (inc > 0) {
      l[top++] = inc & max_32bit_value;
      inc >>= 32;
    }

    l.pos_ = top - 1;
    l.fixPos();
  }

  static BigInteger absDiv(const BigInteger& l, const BigInteger& r,
                           BigInteger& remain) {
    if (l.size() <= 2 && r.size() <= 2) {
      const uint64 a = l.toInt<uint64>();
      const uint64 b = r.toInt<uint64>();
      remain = a % b;
      return a / b;
    }

    const int t = absCompare(l, r);
    if (t < 0) {
      remain = l;
      return 0;
    }
    if (t == 0) {
      remain = 0;
      return 1;
    }

    vector<unsigned int> rb;
    vector<unsigned int> rr = absDivInternal<unsigned int>(
        l.toBinVector<unsigned int>(), r.toBinVector<unsigned int>(), rb);
    remain = BigInteger(rb);
    return rr;
  }

  static BigInteger absDiv(const BigInteger& l, const BigInteger& r) {
    if (l.size() <= 2 && r.size() <= 2) {
      const uint64 a = l.toInt<uint64>();
      const uint64 b = r.toInt<uint64>();
      return a / b;
    }

    const int t = absCompare(l, r);
    if (t < 0) {
      return 0;
    }
    if (t == 0) {
      return 1;
    }

    vector<unsigned int> rb;
    vector<unsigned int> rr = absDivInternal<unsigned int>(
        l.toBinVector<unsigned int>(), r.toBinVector<unsigned int>(), rb);
    return rr;
  }

  template <typename T>
  static vector<T> absDivInternal(const vector<T>& l, const vector<T>& r,
                                  vector<T>& remain) {
    vector<T> result;
    remain = l;

    const int divR = (int)r.size();
    int pos = (int)l.size() - 1;
    int end = pos - divR + 1;
    for (; end >= 0;) {
      if (pos - end + 1 < divR) {
        result.push_back(0);
        --end;
        continue;
      }
      if (remain[pos] == 0) {
        --pos;
        continue;
      }
      int gt = 1;
      if (pos - end + 1 == divR) {
        for (int i = pos, j = divR - 1; i >= end; --i, --j) {
          if (remain[i] < r[j]) {
            gt = 0;
            break;
          } else if (remain[i] > r[j]) {
            break;
          }
        }
      }
      result.push_back(gt);
      if (gt == 0) {
        --end;
        continue;
      }

      int borrow = 0;
      int i = end, j = 0;
      for (; j < divR; ++i, ++j) {
        int nextBorrow = 0;
        auto t = remain[i];
        while (t < r[j] + borrow) {
          t += 2;
          ++nextBorrow;
        }
        remain[i] = t - r[j] - borrow;
        borrow = nextBorrow;
      }

      for (; i <= pos; ++i) {
        int nextBorrow = 0;
        int t = remain[i];
        while (t < borrow) {
          t += 2;
          ++nextBorrow;
        }
        remain[i] = t - borrow;
        borrow = nextBorrow;
      }
      --end;
    }

    if (result.size() == 0) result.push_back(0);
    reverse(result.begin(), result.end());
    fixSize(result);
    fixSize(remain);
    return result;
  }

  template <typename T>
  static BigInteger absDiv(const BigInteger& l, T r, T& remain) {
    static_assert(is_unsigned<T>::value, "T must be unsigned");
    static_assert(sizeof(T) <= 8, "T must be at most 64-bit");
    if (l.size() <= 2) {
      const uint64 a = l.toInt<uint64>();
      const uint64 b = r;
      remain = a % b;
      return a / b;
    }

    BigInteger t(l);
    absDivInplace(t, r, remain);
    return t;
  }

  template <typename T>
  static BigInteger absDiv(const BigInteger& l, T r) {
    static_assert(is_unsigned<T>::value, "T must be unsigned");
    static_assert(sizeof(T) <= 8, "T must be at most 64-bit");
    if (l.size() <= 2) {
      const uint64 a = l.toInt<uint64>();
      const uint64 b = r;
      return a / b;
    }

    BigInteger t(l);
    T remain;
    absDivInplace(t, r, remain);
    return t;
  }

  template <typename T>
  static void absDivInplace(BigInteger& l, T r, T& remain) {
    static_assert(is_unsigned<T>::value, "T must be unsigned");
    static_assert(sizeof(T) <= 8, "T must be at most 64-bit");

    l.fixPos();
    if (l.size() <= 2) {
      const uint64 a = l.toInt<uint64>();
      const uint64 b = r;
      remain = a % b;
      l.resetAbs(a / b);
      return;
    }
#if !PE_HAS_INT128
    if (sizeof(T) > 4) {
      BigInteger tRemain;
      l = absDiv(l, BigInteger(r), tRemain);
      remain = tRemain.toInt<T>();
      return;
    }
#else
    if (r <= max_32bit_value) {
      uint64 add = 0;
      for (int i = l.pos_; i > 0; --i) {
        const uint64 x = add + l.data_[i];
        const uint64 next_add = (x % r) << 32;
        l.data_[i] = x / r;
        add = next_add;
      }
      const uint64 x = add + l.data_[0];
      l.data_[0] = x / r;
      remain = x % r;
      l.fixPos();
    } else {
      uint64 add = 0;
      for (int i = l.pos_; i > 0; --i) {
        const uint128 x = ((uint128)add << 32) + l.data_[i];
        const uint64 next_add = x % r;
        l.data_[i] = x / r;
        add = next_add;
      }
      const uint128 x = ((uint128)add << 32) + l.data_[0];
      l.data_[0] = x / r;
      remain = x % r;
      l.fixPos();
    }
#endif
  }

 public:
  BigInteger& operator+=(const BigInteger& other) {
    if (other.isZero()) {
      // Do nothing
    } else if (isZero()) {
      *this = other;
    } else if (getSign() == other.getSign()) {
      absAddInplace(*this, other);
    } else {
      int c = absCompare(*this, other);
      if (c == 0) {
        pos_ = 0;
        data_[0] = 0;
        sign_ = 0;
      } else if (c > 0) {
        absSubInplace(*this, other);
      } else {
        BigInteger t(other);
        absSubInplace(t, *this);
        *this = std::move(t);
      }
    }
    return *this;
  }

  BigInteger& operator-=(const BigInteger& other) {
    if (other.isZero()) {
      // Do nothing
    } else if (isZero()) {
      *this = other;
      sign_ = -other.sign_;
    } else if (getSign() != other.getSign()) {
      absAddInplace(*this, other);
    } else {
      int c = absCompare(*this, other);
      if (c == 0) {
        pos_ = 0;
        data_[0] = 0;
        sign_ = 0;
      } else if (c > 0) {
        absSubInplace(*this, other);
      } else {
        BigInteger t(other);
        absSubInplace(t, *this);
        *this = std::move(t);
        sign_ = -other.sign_;
      }
    }
    return *this;
  }

  BigInteger& operator*=(const BigInteger& other) {
    *this = *this * other;
    return *this;
  }

  template <typename T>
  REQUIRES(is_native_integer<T>::value)
  RETURN(BigInteger&) operator*=(T other) {
    if (isZero()) {
      return *this;
    }
    if (other == 0) {
      pos_ = 0;
      data_[0] = 0;
      sign_ = 0;
      return *this;
    }
    typedef typename std::make_unsigned<T>::type unsignedT;
    unsignedT absValue = other > 0 ? other : -other;
    absMulInplace(*this, absValue);
    sign_ = sign_ * (other > 0 ? 1 : -1);
    return *this;
  }

  BigInteger& operator/=(const BigInteger& other) {
    *this = *this / other;
    return *this;
  }

  template <typename T>
  REQUIRES(is_native_integer<T>::value)
  RETURN(BigInteger&) operator/=(T other) {
    T r;
    divInplace(*this, other, r);
    return *this;
  }

  BigInteger& operator%=(const BigInteger& other) {
    *this = *this % other;
    return *this;
  }

  template <typename T>
  REQUIRES(is_native_integer<T>::value)
  RETURN(BigInteger&) operator%=(T other) {
    T r;
    divInplace(*this, other, r);
    return *this = r;
  }

  BigInteger& operator^=(const BigInteger& other) {
    *this = *this ^ other;
    return *this;
  }

  BigInteger& operator|=(const BigInteger& other) {
    *this = *this | other;
    return *this;
  }

  template <typename T>
  REQUIRES((is_native_integer<T>::value &&
            !is_same<typename remove_cvref<T>::type, BigInteger>::value))
  RETURN(BigInteger&)
  operator>>=(T other) {
    *this = *this >> other;
    return *this;
  }

  template <typename T>
  REQUIRES((is_native_integer<T>::value &&
            !is_same<typename remove_cvref<T>::type, BigInteger>::value))
  RETURN(BigInteger&)
  operator<<=(T other) {
    *this = *this << other;
    return *this;
  }

  BigInteger& operator++() {
    *this += 1;
    return *this;
  }

  BigInteger operator++(int) {
    BigInteger ret(*this);
    *this += 1;
    return ret;
  }

  BigInteger& operator--() {
    *this -= 1;
    return *this;
  }

  BigInteger operator--(int) {
    BigInteger ret(*this);
    *this -= 1;
    return ret;
  }

 private:
  void fixPos() const {
    while (pos_ > 0 && data_[pos_] == 0) --pos_;
    if (pos_ == 0 && data_[0] == 0) sign_ = 0;
  }

  template <typename T>
  static void fixSize(vector<T>& v) {
    if (v.empty()) v.push_back(0);
    int now = (int)v.size() - 1;
    while (now > 0 && v[now] == 0) --now;
    v.resize(now + 1);
  }

  void reserve(int newSize) {
    PE_ASSERT(newSize > 0);
    unsigned int* oldData = nullptr;
    if (data_) {
      if (newSize > bufferLength_) {
        oldData = data_;
      } else {
        return;
      }
    }

    data_ = bi_allocator::allocate(newSize);
    if (oldData != nullptr) {
      // copy used data only.
      copy(oldData, oldData + pos_ + 1, data_);
      bi_allocator::deallocate(oldData);
    }
    bufferLength_ = newSize;
  }

 public:
  // general util method
  friend ostream& operator<<(ostream& o, const BigInteger& bi);

  string toString() const {
    BigInteger t(*this);
    std::vector<unsigned int> mods;
    t.fixPos();
    stringstream ss;
    if (t.sign_ == -1) ss << "-";

    do {
      uint64 add = 0;
      for (int i = t.pos_; i > 0; --i) {
        const uint64 x = add + t.data_[i];
        const uint64 next_add = (x % output_mod) << 32;
        t.data_[i] = (unsigned)(x / output_mod);
        add = next_add;
      }
      uint64 x = add + t.data_[0];
      t.data_[0] = (unsigned)(x / output_mod);
      mods.push_back(x % output_mod);
      t.fixPos();
    } while (!t.isZero());

    int idx = (int)mods.size() - 1;
    char buff[32];
    sprintf(buff, "%u", mods[idx--]);
    ss << buff;
    for (; idx >= 0; --idx) {
      sprintf(buff, "%0*u", output_mod_dig, mods[idx]);
      ss << buff;
    }
    string ret;
    ss >> ret;
    return ret;
  }

  void dump() const {
    dbg(sign_);
    dbg(pos_);
    dbg(bufferLength_);
    for (int i = 0; i <= pos_; ++i) cerr << data_[i] << ",";
    cerr << endl;
  }

  bool isZero() const { return sign_ == 0; }

  int getSign() const { return sign_; }

  unsigned int operator[](int idx) const { return data_[idx]; }

  unsigned int& operator[](int idx) { return data_[idx]; }

  const unsigned int* data() const { return data_; }

  unsigned int* data() { return data_; }

  int size() const { return pos_ + 1; }

  template <typename T>
  REQUIRES(is_native_integer<T>::value)
  RETURN(vector<T>) toBinVector() const {
    vector<T> ret;
    for (int i = 0; i <= pos_; ++i) {
      auto t = data_[i];
      for (int j = 0; j < 32; ++j) ret.push_back(t & 1), t >>= 1;
    }
    fixSize(ret);
    return ret;
  }

  template <typename T>
  REQUIRES(is_native_integer<T>::value&& std::is_signed<T>::value)
  RETURN(T) toInt() const {
    T result = 0;
    for (int i = pos_; i >= 0; --i) result = (result << 32) | data_[i];
    if (std::is_signed<T>::value) {
      if (sign_ < 0) {
        result = -result;
      }
    }
    return result;
  }

  template <typename T>
  REQUIRES(is_native_integer<T>::value&& std::is_unsigned<T>::value)
  RETURN(T) toInt() const {
    T result = 0;
    for (int i = pos_; i >= 0; --i) result = (result << 32) | data_[i];
    if (std::is_signed<T>::value) {
      // Warning
    }
    return result;
  }

  double toDouble() const {
    double result = 0;
    for (int i = pos_; i >= 0; --i) result = result * 4294967296 + data_[i];
    if (sign_ < 0) {
      result = -result;
    }
    return result;
  }

  long double toLongDouble() const {
    long double result = 0;
    for (int i = pos_; i >= 0; --i) result = result * 4294967296 + data_[i];
    if (sign_ < 0) {
      result = -result;
    }
    return result;
  }

  int bitCount() const {
    int ret = pos_ << div32_bit;
    int hiCnt = 0;
    unsigned int v = data_[pos_];
    for (unsigned int x = 1; v; ++hiCnt, x <<= 1, v >>= 1)
      ;
    return ret + hiCnt;
  }

  int bitAt(int t) const {
    const int x = t >> div32_bit;
    const int y = t & mod32_mask;
    return x > pos_ ? 0 : (data_[x] >> y) & 1;
  }

 private:
  unsigned int* data_;
  int bufferLength_;
  mutable int pos_;
  mutable int sign_;
};

inline int operator>(const BigInteger& l, const BigInteger& r) {
  const int s1 = l.sign_;
  const int s2 = r.sign_;

  if (s1 < 0) {
    return s2 < 0 && BigInteger::absCompare(l, r) < 0;
  } else if (s1 > 0) {
    return s2 <= 0 || BigInteger::absCompare(l, r) > 0;
  } else {
    return s2 < 0;
  }
}

inline int operator<(const BigInteger& l, const BigInteger& r) {
  const int s1 = l.sign_;
  const int s2 = r.sign_;

  if (s1 < 0) {
    return s2 >= 0 || BigInteger::absCompare(l, r) > 0;
  } else if (s1 > 0) {
    return s2 > 0 && BigInteger::absCompare(l, r) < 0;
  } else {
    return s2 > 0;
  }
}

inline int operator==(const BigInteger& l, const BigInteger& r) {
  return l.sign_ == r.sign_ && BigInteger::absCompare(l, r) == 0;
}

inline int operator>=(const BigInteger& l, const BigInteger& r) {
  const int s1 = l.sign_;
  const int s2 = r.sign_;

  if (s1 < 0) {
    return s2 < 0 && BigInteger::absCompare(l, r) <= 0;
  } else if (s1 > 0) {
    return s2 <= 0 || BigInteger::absCompare(l, r) >= 0;
  } else {
    return s2 <= 0;
  }
}

inline int operator<=(const BigInteger& l, const BigInteger& r) {
  const int s1 = l.sign_;
  const int s2 = r.sign_;

  if (s1 < 0) {
    return s2 >= 0 || BigInteger::absCompare(l, r) >= 0;
  } else if (s1 > 0) {
    return s2 > 0 && BigInteger::absCompare(l, r) <= 0;
  } else {
    return s2 >= 0;
  }
}

inline int operator!=(const BigInteger& l, const BigInteger& r) {
  return !(l == r);
}

inline BigInteger operator+(const BigInteger& l, const BigInteger& r) {
  BigInteger ret(l);
  ret += r;
  return ret;
}

inline BigInteger operator-(const BigInteger& l, const BigInteger& r) {
  if (r.isZero()) {
    return l;
  } else if (l.isZero()) {
    return -r;
  } else if (l.getSign() != r.getSign()) {
    BigInteger t(l);
    BigInteger::absAddInplace(t, r);
    return t;
  } else {
    int c = BigInteger::absCompare(l, r);
    if (c == 0) {
      return 0;
    } else if (c > 0) {
      BigInteger t(l);
      BigInteger::absSubInplace(t, r);
      return t;
    } else {
      BigInteger t(r);
      BigInteger::absSubInplace(t, l);
      t.sign_ = -r.sign_;
      return t;
    }
  }
}

inline BigInteger operator*(const BigInteger& l, const BigInteger& r) {
  if (l.isZero() || r.isZero()) return 0;

  const int s = l.getSign() * (r > 0 ? 1 : -1);
  BigInteger ret(BigInteger::absMul(l, r));
  ret.sign_ = s;

  return ret;
}

template <typename T>
inline REQUIRES((is_native_integer<T>::value &&
                 !is_same<typename remove_cvref<T>::type, BigInteger>::value))
    RETURN(BigInteger)
    operator*(const BigInteger& l, T r) {
  if (r == 0 || l.isZero()) return 0;

  typedef typename std::make_unsigned<T>::type unsignedT;
  unsignedT absValue = r > 0 ? r : -r;
  const int s = l.getSign() * (r > 0 ? 1 : -1);
  BigInteger ret(BigInteger::absMul(l, absValue));
  ret.sign_ = s;

  return ret;
}

template <typename T>
inline REQUIRES((is_native_integer<T>::value &&
                 !is_same<typename remove_cvref<T>::type, BigInteger>::value))
    RETURN(BigInteger)
    operator*(T l, const BigInteger& r) {
  return r * l;
}

inline BigInteger operator/(const BigInteger& l, const BigInteger& r) {
  BigInteger u, v;
  tie(u, v) = div(l, r);
  return u;
}

template <typename T>
inline REQUIRES((is_native_integer<T>::value &&
                 !is_same<typename remove_cvref<T>::type, BigInteger>::value))
    RETURN(BigInteger)
    operator/(const BigInteger& l, T r) {
  BigInteger u;
  T v;
  tie(u, v) = div(l, r);
  return u;
}

inline tuple<BigInteger, BigInteger> div(const BigInteger& l,
                                         const BigInteger& r) {
  if (l.isZero() && r.isZero()) {
    return make_tuple(1, 0);
  }
  if (l.isZero() || r.isZero()) {
    return make_tuple(0, 0);
  }

  if (r.size() > 2) {
    BigInteger x;
    BigInteger ret(BigInteger::absDiv(l, r, x));
    ret.sign_ = l.sign_ * r.sign_;
    ret.fixPos();
    x.sign_ = l.sign_;
    x.fixPos();

    return make_tuple(std::move(ret), std::move(x));
  } else {
    uint64 absValue = r.toInt<uint64>();
    uint64 x;
    BigInteger ret(l);
    BigInteger::absDivInplace(ret, absValue, x);
    ret.sign_ = l.getSign() * (r.getSign() > 0 ? 1 : -1);
    ret.fixPos();

    BigInteger remain(x);
    if (l.sign_ < 0) {
      remain.sign_ = -remain.sign_;
    }
    return make_tuple(std::move(ret), std::move(remain));
  }
}

template <typename T>
inline REQUIRES((is_native_integer<T>::value &&
                 !is_same<typename remove_cvref<T>::type, BigInteger>::value))
    RETURN(tuple<BigInteger, T>) div(const BigInteger& l, T r) {
  if (l.isZero() && r == 0) {
    return make_tuple(1, 0);
  }
  if (l.isZero() || r == 0) {
    return make_tuple(0, 0);
  }

  const int signl = l.sign_;
  typedef typename std::make_unsigned<T>::type unsignedT;
  unsignedT absValue = r > 0 ? r : -r;
  unsignedT x;
  BigInteger ret(l);
  BigInteger::absDivInplace(ret, absValue, x);
  ret.sign_ = signl * (r > 0 ? 1 : -1);
  ret.fixPos();
  if (l.sign_ < 0) {
    PE_ASSERT(x == 0 || !std::is_unsigned<T>::value);
    x = BigInteger::getAbsValue(x);
  }

  return make_tuple(std::move(ret), (T)x);
}

template <typename T>
inline REQUIRES((is_native_integer<T>::value &&
                 !is_same<typename remove_cvref<T>::type, BigInteger>::value))
    RETURN(void) divInplace(BigInteger& l, T r, T& remain) {
  if (l.isZero() && r == 0) {
    l = 1;
    remain = 0;
    return;
  }

  if (l.isZero() || r == 0) {
    if (!l.isZero()) {
      l.pos_ = 0;
      l.data_[0] = 0;
      l.sign_ = 0;
    }
    remain = 0;
    return;
  }
  typedef typename std::make_unsigned<T>::type unsignedT;
  unsignedT absValue = r > 0 ? r : -r;
  unsignedT remainT;
  const int signl = l.sign_;
  BigInteger::absDivInplace(l, absValue, remainT);
  l.sign_ = signl * (r > 0 ? 1 : -1);
  l.fixPos();
  remain = (T)remainT;
  if (l.sign_ < 0) {
    PE_ASSERT(remain == 0 || !std::is_unsigned<T>::value);
    remain = -remain;
  }
}

inline BigInteger operator%(const BigInteger& l, const BigInteger& r) {
  BigInteger u, v;
  tie(u, v) = div(l, r);
  return v;
}

template <typename T>
inline REQUIRES((is_native_integer<T>::value &&
                 !is_same<typename remove_cvref<T>::type, BigInteger>::value))
    RETURN(T)
    operator%(const BigInteger& l, T r) {
  BigInteger u;
  T v;
  tie(u, v) = div(l, r);
  return v;
}

inline BigInteger operator&(const BigInteger& l, const BigInteger& r) {
  if (l.size() <= 2 && r.size() <= 2) {
    return l.toInt<uint64>() & r.toInt<uint64>();
  }

  const int minPos = min(l.pos_, r.pos_);
  BigInteger ret(minPos + 1, alloc_mem_tag);
  for (int i = 0; i <= minPos; ++i) {
    ret[i] = l[i] & r[i];
  }
  ret.pos_ = minPos;
  ret.sign_ = 1;
  ret.fixPos();
  return ret;
}

inline BigInteger operator^(const BigInteger& l, const BigInteger& r) {
  if (l.size() <= 2 && r.size() <= 2) {
    return l.toInt<uint64>() ^ r.toInt<uint64>();
  }

  const int maxPos = max(l.pos_, r.pos_);
  BigInteger ret(maxPos + 1, alloc_mem_tag);
  for (int i = 0; i <= maxPos; ++i) {
    unsigned int t = 0;
    if (i <= l.pos_) t ^= l[i];
    if (i <= r.pos_) t ^= r[i];
    ret[i] = t;
  }
  ret.pos_ = maxPos;
  ret.sign_ = 1;
  ret.fixPos();
  return ret;
}

inline BigInteger operator|(const BigInteger& l, const BigInteger& r) {
  if (l.size() <= 2 && r.size() <= 2) {
    return l.toInt<uint64>() | r.toInt<uint64>();
  }

  const int maxPos = max(l.pos_, r.pos_);
  BigInteger ret(maxPos + 1, alloc_mem_tag);
  for (int i = 0; i <= maxPos; ++i) {
    unsigned int t = 0;
    if (i <= l.pos_) t |= l[i];
    if (i <= r.pos_) t |= r[i];
    ret[i] = t;
  }
  ret.pos_ = maxPos;
  ret.sign_ = 1;
  ret.fixPos();
  return ret;
}

template <typename T>
inline REQUIRES((is_native_integer<T>::value &&
                 !is_same<typename remove_cvref<T>::type, BigInteger>::value))
    RETURN(BigInteger)
    operator<<(const BigInteger& l, T n) {
  if (l.getSign() == 0) {
    return 0;
  }
  if (n == 0) {
    return l;
  }
  const int bitCnt = l.bitCount();
  vector<unsigned int> v(n + bitCnt, 0);
  for (int i = 0, j = n; i < bitCnt; ++i, ++j) {
    const int x = i >> BigInteger::div32_bit;
    const int y = i & BigInteger::mod32_mask;
    v[j] = (l[x] >> y) & 1;
  }
  BigInteger ret(v);
  ret.sign_ = l.sign_;
  ret.fixPos();
  return ret;
}

template <typename T>
inline REQUIRES((is_native_integer<T>::value &&
                 !is_same<typename remove_cvref<T>::type, BigInteger>::value))
    RETURN(BigInteger)
    operator>>(const BigInteger& l, T n) {
  if (l.getSign() == 0) {
    return 0;
  }
  if (n == 0) {
    return l;
  }
  const int bitCnt = l.bitCount();
  if (n >= bitCnt) {
    return 0;
  }

  vector<unsigned int> v(bitCnt - n, 0);
  for (int i = n, j = 0; i < bitCnt; ++i, ++j) {
    const int x = i >> BigInteger::div32_bit;
    const int y = i & BigInteger::mod32_mask;
    v[j] = (l[x] >> y) & 1;
  }

  BigInteger ret(v);
  ret.sign_ = l.sign_;
  ret.fixPos();

  return ret;
}

template <typename T>
inline REQUIRES((is_native_integer<T>::value &&
                 !is_same<typename remove_cvref<T>::type, BigInteger>::value))
    RETURN(BigInteger) power(const BigInteger& l, T n) {
  BigInteger ret(1);
  BigInteger x(l);
  for (; n > 0; n >>= 1) {
    if (n & 1) ret = ret * x;
    if (n > 1) x = x * x;
  }
  return ret;
}

template <typename T>
inline REQUIRES((is_native_integer<T>::value &&
                 !is_same<typename remove_cvref<T>::type, BigInteger>::value))
    RETURN(BigInteger)
        power_mod(const BigInteger& l, T n, const BigInteger& mod) {
  if (mod == 1) {
    return 0;
  }
  BigInteger ret(1);
  BigInteger x(l % mod);
  for (; n > 0; n >>= 1) {
    if (n & 1) ret = ret * x % mod;
    if (n > 1) x = x * x % mod;
  }
  return ret;
}

inline BigInteger power_mod(const BigInteger& l, const BigInteger& m,
                            const BigInteger& mod) {
  if (mod == 1) {
    return 0;
  }
  BigInteger ret(1);
  BigInteger x(l % mod);
  BigInteger n(m);
  for (; n.getSign() > 0;) {
    if (n[0] & 1) ret = ret * x % mod;
    n >>= 1;
    if (n.getSign() > 0) x = x * x % mod;
  }
  return ret;
}

inline BigInteger exgcd(const BigInteger& a, const BigInteger& b, BigInteger& x,
                        BigInteger& y) {
  if (b.isZero()) {
    x = 1;
    y = 0;
    return a;
  }

  BigInteger x1 = 0, y1 = 0;
  BigInteger ret = exgcd(b, a % b, x1, y1);
  // b * x1 + (a%b) * y1 = ret
  // b * x1 + (a - a / b * b) * y1 = ret
  // b * x1 + a * y1 - a / b * b * y1 = ret
  // y1 * a + (x1 - a / b * y1) b = ret
  y = x1 - a / b * y1;
  x = std::move(y1);
  return ret;
}

SL tuple<BigInteger, BigInteger, BigInteger> exgcd(const BigInteger& a, const BigInteger& b) {
  PE_ASSERT(a != 0 || b != 0);
  BigInteger x = 0, y = 0;
  const BigInteger r = exgcd(a, b, x, y);
  PE_ASSERT(a * x + b * y == r);
  return tuple<BigInteger, BigInteger, BigInteger>{r, x, y};
}

inline BigInteger gcd(BigInteger m, BigInteger n) {
  while (!n.isZero()) {
    BigInteger t = m % n;
    m = std::move(n);
    n = std::move(t);
  }
  return m;
}

inline BigInteger mod_inv(const BigInteger& a, const BigInteger& mod) {
  BigInteger x, y;
  exgcd(a, mod, x, y);
  x %= mod;
  if (x.getSign() < 0) {
    x += mod;
  }
  return x;
}

inline BigInteger fabs(const BigInteger& n) {
  return n.getSign() >= 0 ? n : -n;
}

inline BigInteger abs(const BigInteger& n) { return n.getSign() >= 0 ? n : -n; }

inline ostream& operator<<(ostream& o, const BigInteger& bi) {
  return o << bi.toString();
}

SL string to_string(const BigInteger& x) { return x.toString(); }

inline BigInteger operator"" _bi(const char* sv, size_t sc) {
  return BigInteger(string(sv));
}

inline BigInteger operator"" _bi(unsigned long long v) { return BigInteger(v); }

typedef BigInteger bi;
typedef BigInteger bn;

// solve equation a x = b (mod m)
// return 0 and set u = -1 and v = 0 if failed
// return 1, x = v (mod u)
SL int solve_linear_equation(bn a, bn b, bn m, bn& v, bn& u) {
  v = 0;
  u = 0;

  if (m < 0) m = -m;

  a %= m;
  b %= m;

  if (a < 0) a += m;
  if (b < 0) b += m;

  bn xx = 0, yy = 0, d = exgcd(a, m, xx, yy);

  if (!(b % d).isZero()) return 0;

  xx = (xx % m + m) % m;
  xx = xx * (b / d) % m;

  u = m / d;
  v = xx % u;

  return 1;
}

// solve equation x = a (mod m1) x = b (mod m2)
// return 0 and set u = 0 and t = 0 if failed
// return 1, x = v (mod u)
SL int crt2(bn a, bn m1, bn b, bn m2, bn& v, bn& u) {
  v = 0;
  u = 0;

  PE_ASSERT(m1 != 0 && m2 != 0);
  if (m1 < 0) m1 = -m1;
  if (m2 < 0) m2 = -m2;
  // x = a (mod m1)
  // x = b (mod m2)
  // x = k0 m1 + a
  // k0 m1 + a = b (mod m2)
  // k0 m1 = b - a (mod m2)
  a %= m1;
  b %= m2;
  if (a < 0) a = -a;
  if (b < 0) b = -b;

  bn s = 0, t = 0;
  if (!solve_linear_equation(m1, b - a, m2, t, s)) return 0;
  // k0 = k1 * s + t
  // x = (k1 * s + t) * m1 + a
  // x = k1 * s * m1 + (a + t * m1)

  u = s * m1;
  v = ((a + t * m1) % u + u) % u;
  return 1;
}

SL tuple<int, bn, bn> crt2(bn a, bn m1, bn b, bn m2) {
  bn v = 0, u = 0;
  int r = crt2(a, m1, b, m2, v, u);
  return tuple<int, bn, bn>{r, v, u};
}

SL tuple<int, bn, bn> crtn(bn* val, bn* mod, int n) {
  bn v = 0, u = 1;
  int have = 1;
  for (int i = 0; i < n; ++i) {
    tie(have, v, u) = crt2(v, u, val[i], mod[i]);
    if (!have) {
      return tuple<int, bn, bn>{0, 0, 0};
    }
  }
  return tuple<int, bn, bn>{have, v, u};
}

template <>
struct Fraction<bi> {
  Fraction(const bi& u = 0, const bi& v = 1) : a(u), b(v) {
    auto d = gcd(abs(a), abs(b));
    if (d > 1) a /= d, b /= d;
    if (b < 0) b = -b, a = -a;
  }
  int operator<(const Fraction& o) const { return a * o.b < b * o.a; }
  int operator>(const Fraction& o) const { return a * o.b > b * o.a; }
  int operator==(const Fraction& o) const { return a * o.b == b * o.a; }
  Fraction operator+(const Fraction& o) const {
    return Fraction(a * o.b + o.a * b, b * o.b);
  }
  Fraction operator-(const Fraction& o) const {
    return Fraction(a * o.b - o.a * b, b * o.b);
  }
  Fraction operator*(const Fraction& o) const {
    return Fraction(a * o.a, b * o.b);
  }
  Fraction operator/(const Fraction& o) const {
    return Fraction(a * o.b, b * o.a);
  }
  double toDouble() { return 1. * a.toDouble() / b.toDouble(); }
  long double toLongDouble() {
    return (long double)1. * a.toLongDouble() / b.toLongDouble();
  }
  bi a, b;
};

template <typename T>
Fraction<bi> from_continued_fraction(const vector<T>& data, int pos = -1) {
  const int size = (int)data.size();
  const int n = pos <= 0 ? 1 : min(size, pos + 1);
  Fraction<bi> now(data[n - 1], 1);
  for (int i = n - 2; i >= 0; --i) {
    now = Fraction<bi>(data[i] * now.a + now.b, now.a);
  }
  return now;
}

bi find_integer_part(const bi& a, const bi& q, const bi& b, const bi& c) {
  // a q^(1/2) + b >= c x
  long double test =
      (a.toLongDouble() * sqrt(q.toLongDouble()) + b.toLongDouble()) /
      c.toLongDouble();
  bi now = (int64)test;
  const bi target = a * a * q;
  for (;;) {
    bi next = now + 1;
    bi t = sq(c * next - b);
    if (t <= target) {
      now = next;
    } else {
      break;
    }
  }
  return now;
}

// convert p sqrt(q) to continued fraction
// q is square free
vector<bi> to_continued_fraction(int64 p, int64 q, int n) {
  vector<bi> result;
  bi a = p, f = q, b = 0, c = 1;
  // (a f^(1/2) + b) / c
  bi val = find_integer_part(a, f, b, c);
  result.pb(val);
  b = b - val * c;

  while (result.size() < n) {
    // (a f^(1/2) + b) / c
    // c * (aq^(1/2) - b)
    auto cc = a * a * f - b * b;
    auto aa = c * a;
    auto bb = -c * b;
    bi val = find_integer_part(aa, f, bb, cc);
    result.pb(val);
    a = aa;
    b = bb - val * cc;
    c = cc;
    auto d = abs(gcd(gcd(a, b), c));
    if (d > 1) {
      a /= d;
      b /= d;
      c /= d;
    }
  }

  return result;
}

struct FacModer {
  std::vector<bi> F;
  int64 p;
  int64 e;
  bi mod;
  bi phi;

  FacModer(const int64 p, const int64 e) : p(p), e(e) {
    int64 pe = p * e;
    mod = power(bi(p), e);
    phi = power(bi(p), (e - 1)) * (p - 1);
    F.resize(pe + 1, 1);
    for (int i = 1; i <= pe; ++i) {
      if (i % p == 0)
        F[i] = F[i - 1];
      else
        F[i] = F[i - 1] * i % mod;
    }
  }

  bi cal(const bi& N) {
    bi u;
    bi v;
    tie(u, v) = div(N, p);
    int64 vv = v.toInt<int64>();
    int64 r = (e + 1) >> 1;

    bi ret = 1;
    // F(up, p)
    const bi u2 = u * u;

    for (int j = 1; j <= r; ++j) {
      bi beta_numer = u;
      bi beta_denom = j;
      const int j2 = j * j;
      for (int i = 1; i <= r; ++i)
        if (i != j) beta_numer *= u2 - i * i, beta_denom *= j2 - i * i;
      auto beta = beta_numer / beta_denom % phi;
      if (beta.getSign() < 0) beta += phi;
      ret = ret * power_mod(F[j * p], beta, mod) % mod;
    }

    if (p == 2) {
      int64 left_mod4 = (((u * p + 1)[0] & 4) >> 1) + 1;
      int64 right_mod4 = ret[0] & 3;
      if (left_mod4 != right_mod4) {
        ret = (mod - ret) % mod;
      }
    }

    // F(v, p)
    ret = ret * F[vv] % mod;

    // (p + v, v)_p
    for (int j = 1; j < e; ++j) {
      auto base = F[j * p + vv] * mod_inv(F[vv] * F[j * p], mod) % mod;
      bi alpha_numer = u;
      bi alpha_denom = j;
      for (int i = 1; i < e; ++i)
        if (i != j) {
          alpha_numer *= u - i;
          alpha_denom *= j - i;
        }
      auto alpha = alpha_numer / alpha_denom % phi;
      if (alpha.getSign() < 0) alpha += phi;
      ret = ret * power_mod(base, alpha, mod) % mod;
    }

    return ret;
  }
};
#endif
