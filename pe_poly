#ifndef __PE_POLY__
#define __PE_POLY__

#include "pe_base"
#include "pe_integer_util"
#include "pe_mod"
#include "pe_ntt"
#include "pe_poly_algo"

int64 POLY_DEFAULT_MOD = 1;

struct Poly {
  int64 mod;
  std::vector<int64> data;

  Poly(int64 mod = 0) : mod(mod == 0 ? POLY_DEFAULT_MOD : mod) {}

  Poly(const std::vector<int64>& data, int64 mod = 0)
      : data(data), mod(mod == 0 ? POLY_DEFAULT_MOD : mod) {
    adjust_mod().adjust_leading_zeros();
  }

  Poly(std::vector<int64>&& data, int64 mod = 0)
      : data(std::move(data)), mod(mod == 0 ? POLY_DEFAULT_MOD : mod) {
    adjust_mod().adjust_leading_zeros();
  }

  Poly& operator=(const vector<int64>& v) {
    data = v;
    return *this;
  }

  Poly& operator=(const vector<int64>&& v) {
    data = std::move(v);
    return *this;
  }

  Poly(const Poly& p) = default;
  Poly(Poly&& p) = default;
  Poly& operator=(const Poly& other) = default;
  Poly& operator=(Poly&& other) = default;

  Poly& adjust_leading_zeros() {
    adjust_poly_leading_zero(data);
    return *this;
  }

  Poly& adjust_mod() {
    for (auto& iter : data) {
      iter = regulate_mod(iter, mod);
    }
    return *this;
  }

  int deg() const { return static_cast<int>(data.size() - 1); }
  int size() const { return static_cast<int>(data.size()); }

  Poly& resize(int n) {
    const int m = (int)data.size();
    data.resize(n);
    for (int i = m; i < n; ++i) {
      data[i] = 0;
    }
    return *this;
  }

  Poly& redeg(int n) { return resize(n + 1); }

  int64& operator[](int idx) {
    PE_ASSERT(idx >= 0 && idx < data.size());
    return data[idx];
  }

  int64 operator[](int idx) const {
    PE_ASSERT(idx >= 0 && idx < data.size());
    return data[idx];
  }

  int64 at(int idx) const {
    return idx >= 0 && idx < data.size() ? data[idx] : 0;
  }

  bool isZero() const { return data.size() == 1 && data[0] == 0; }

  int64 valueAt(int64 v) const {
    int64 ret = 0;
    for (int i = deg(); i >= 0; --i) {
      ret = ret * v % mod + data[i];
      if (ret >= mod) ret -= mod;
    }
    return ret;
  }

  Poly lowerTerms(int n) const {
    const int m = min(n, static_cast<int>(data.size()));
    return Poly(std::vector<int64>(data.begin(), data.begin() + m), mod);
  }

  Poly inv(int n) const;
};

template <int64 M>
struct PolyM : public Poly {
  PolyM() : Poly(M) {}

  PolyM(const std::vector<int64>& data) : Poly(data, M) {}

  PolyM(std::vector<int64>&& data) : Poly(std::move(data), M) {}

  PolyM(std::initializer_list<int64> l) : PolyM(std::vector<int64>(l)) {}
};

SL Poly poly_mul_normal(const Poly& X, const Poly& Y) {
  return Poly{poly_mul_normal(X.data, Y.data, X.mod), X.mod};
}

#if HAS_POLY_MUL_NTT
SL Poly poly_mul_ntt(const Poly& X, const Poly& Y) {
  return Poly{ntt::poly_mul_ntt(X.data, Y.data, X.mod), X.mod};
}
#endif

SL Poly poly_mul(const Poly& X, const Poly& Y) {
  return Poly{poly_mul(X.data, Y.data, X.mod), X.mod};
}

SL Poly poly_inv_mod(const Poly& x, int n) {
  // It is assumed that mod is a prime
  return Poly(poly_inv_mod(x.data, n, x.mod), x.mod);
}

SL tuple<Poly, Poly> poly_div_and_mod(const Poly& x, const Poly& y) {
  vector<int64> q, r;
  tie(q, r) = poly_div_and_mod(x.data, y.data, x.mod);
  return make_tuple(Poly(std::move(q), x.mod), Poly(std::move(r), x.mod));
}

#define PPOLY_DIV_AND_MOD_IMPL(poly_div_and_mod, poly_div_and_mod_internal)  \
  SL tuple<Poly, Poly> poly_div_and_mod(const Poly& X, const Poly& Y) {      \
    vector<int64> q, r;                                                      \
    tie(q, r) = poly_div_and_mod(X.data, Y.data, X.mod);                     \
    return make_tuple(Poly(std::move(q), X.mod), Poly(std::move(r), X.mod)); \
  }

#define PPOLY_DIV_IMPL(poly_div, poly_div_and_mod)       \
  SL Poly poly_div(const Poly& X, const Poly& Y) {       \
    return Poly(poly_div(X.data, Y.data, X.mod), X.mod); \
  }

#define PPOLY_MOD_IMPL(poly_mod, poly_div_and_mod)       \
  SL Poly poly_mod(const Poly& X, const Poly& Y) {       \
    return Poly(poly_mod(X.data, Y.data, X.mod), X.mod); \
  }

PPOLY_DIV_AND_MOD_IMPL(poly_div_and_mod_dc, poly_div_and_mod_dc_internal)
PPOLY_DIV_IMPL(poly_div_dc, poly_div_and_mod_dc)
PPOLY_MOD_IMPL(poly_mod_dc, poly_div_and_mod_dc)

PPOLY_DIV_AND_MOD_IMPL(poly_div_and_mod_normal,
                       poly_div_and_mod_normal_internal)
PPOLY_DIV_IMPL(poly_div_normal, poly_div_and_mod_normal)
PPOLY_MOD_IMPL(poly_mod_normal, poly_div_and_mod_normal)

PPOLY_DIV_IMPL(poly_div, poly_div_and_mod)
PPOLY_MOD_IMPL(poly_mod, poly_div_and_mod)

inline Poly Poly::inv(int n) const {
  // It is assumed that mod is a prime
  auto t = poly_inv_mod(data, n, mod);
  return Poly(std::vector<int64>((int64*)&t[0], (int64*)&t[0] + t.size()), mod);
}

Poly operator<<(const Poly& p, int m) {
  if (m == 0) {
    return p;
  }
  std::vector<int64> new_data(p.data.size() + m);
  for (int i = static_cast<int>(p.data.size()) + m - 1; i >= m; --i) {
    new_data[i] = p.data[i - m];
  }
  for (int i = 0; i < m; ++i) {
    new_data[i] = 0;
  }
  return Poly(std::move(new_data), p.mod);
}

SL Poly operator-(const Poly& x, const Poly& y) {
  const int n = max(x.deg(), y.deg());
  std::vector<int64> data(n + 1);
  for (int i = 0; i <= n; ++i) {
    data[i] = sub_mod(x.at(i), y.at(i), x.mod);
  }
  return Poly(std::move(data), x.mod).adjust_leading_zeros();
}

SL Poly operator+(const Poly& x, const Poly& y) {
  const int n = max(x.deg(), y.deg());
  std::vector<int64> data(n + 1);
  for (int i = 0; i <= n; ++i) {
    data[i] = add_mod(x.at(i), y.at(i), x.mod);
  }
  return Poly(std::move(data), x.mod).adjust_leading_zeros();
}

SL Poly operator*(const Poly& x, int64 v) {
  std::vector<int64> data(x.data);
  for (auto& iter : data) {
    iter = iter * v % x.mod;
  }
  return Poly(std::move(data), x.mod);
}

SL Poly operator*(int64 v, const Poly& x) { return x * v; }

SL Poly operator*(const Poly& x, const Poly& y) { return poly_mul(x, y); }

SL Poly operator/(const Poly& x, const Poly& y) { return poly_div(x, y); }

SL Poly operator%(const Poly& x, const Poly& y) { return poly_mod(x, y); }

SL int operator==(const Poly& x, const Poly& y) {
  return x.mod == y.mod && x.data == y.data;
}

// x^n % mod
SL Poly operator%(int64 n, const Poly& mod) {
  Poly x{{0, 1}, mod.mod};
  Poly ret{{1}, mod.mod};
  for (; n > 0; n >>= 1) {
    if (n & 1) {
      ret = poly_mod(x * ret, mod);
    }
    if (n > 1) {
      x = poly_mod(x * x, mod);
    }
  }
  return ret;
}

SL ostream& operator<<(ostream& o, const Poly& p) {
  const int n = p.data.size();
  for (int i = 0; i < n - 1; ++i) {
    o << p.data[i] << ", ";
  }
  return o << p.data[n - 1];
}

// size x = size v
SL vector<int64> poly_evaluate_mod_normal(const Poly& X,
                                          const vector<int64>& V) {
  return poly_evaluate_mod_normal(X.data, V, X.mod);
}

// size x = size v
SL vector<int64> poly_evaluate_mod_bls(const Poly& X, const vector<int64>& V) {
  return poly_evaluate_mod_bls(X.data, V, X.mod);
}

// gf_first, gf_at is good for the case size(A) is small.
// Otherwise, A.inv(n) * B is better.

// Finds the coefficient of x^0..x^n of f such that: A*f = B
// Returns empty vector if there is no integer solution.
// O(size(A) * n)
SL vector<int64> gf_first(const Poly& A, const Poly& B, const int n) {
  return gf_first(A.data, B.data, n, A.mod);
}

// Finds the coefficient of x^n of f such that: A*f = B
// Returns -1 if there is no integer solution.
// O(size(A)^3 * log n) for big n
SL int64 gf_at(const Poly& A, const Poly& B, const int64 n) {
  return gf_at(A.data, B.data, n, A.mod);
}

// Berlekamp Massey
SL Poly find_minimal_poly(const Poly& s) {
  const int m = s.data.size();
  const int n = m >> 1;
  const int64 mod = s.mod;
  PE_ASSERT(n * 2 == m);

  Poly r0{{1}, mod};
  r0 = r0 << m;
  Poly r1(s);
  Poly v0{{0}, mod};
  Poly v1{{1}, mod};

  while (n + 1 <= r1.deg()) {
    Poly q, r;
    tie(q, r) = poly_div_and_mod(r0, r1);
    Poly v(v0 - q * v1);
    v0 = std::move(v1);
    v1 = std::move(v);
    r0 = std::move(r1);
    r1 = std::move(r);
  }
  v1 = std::move(inv_of(v1[0], mod) * v1);
  reverse(v1.data.begin(), v1.data.end());
  return v1;
}

SL int64 nth_element(const Poly& s, int64 n, const Poly& min_poly) {
  if (n <= s.deg()) {
    return s[n];
  }

  auto r = n % min_poly;
  const int m = r.deg();
  int64 ans = 0;
  for (int i = 0; i <= m; ++i) {
    ans = add_mod(ans, s[i] * r[i] % s.mod, s.mod);
  }
  return ans;
}

SL Poly find_linear_recurrence(const Poly& s) {
  const int len = s.data.size();
  for (int n = 2; n < len; n += 2) {
    auto use = s.lowerTerms(n);
    auto min_poly = find_minimal_poly(use);
    int ok = 1;
    for (int i = n; i < len; ++i) {
      auto value = nth_element(use, i, min_poly);
      if (value != s[i]) {
        ok = 0;
        break;
      }
    }
    if (ok) {
      return min_poly;
    }
  }
  return Poly();
}

SL int64 nth_element(const Poly& s, int64 n) {
  if (n <= s.deg()) {
    return s[n];
  }

  auto min_poly = find_linear_recurrence(s);
  if (min_poly.deg() > 0) {
    return nth_element(s, n, min_poly);
  }
  return -1;
}
#endif
