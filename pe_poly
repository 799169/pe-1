#ifndef __PE_POLY__
#define __PE_POLY__

#include "pe_base"
#include "pe_integer_util"
#include "pe_mod"
#include "pe_ntt"

template <int64 P>
struct PolyM {
  std::vector<int64> data;

  PolyM() {}

  PolyM(const std::vector<int64>& data): data(data) {
    adjust_mod().adjust_leading_zeros();
  }
  PolyM(std::vector<int64>&& data): data(std::move(data)) {
    adjust_mod().adjust_leading_zeros();
  }

  PolyM& operator = (const vector<int64>& v) {
    data = v;
    return *this;
  }

  PolyM& operator = (const vector<int64>&& v) {
    data = std::move(v);
    return *this;
  }

  PolyM(std::initializer_list<int64> l) : data(l) {
    adjust_leading_zeros().adjust_mod();
  }

  PolyM(const PolyM& p) = default;
  PolyM(PolyM&& p) = default;
  PolyM<P>& operator=(const PolyM& other) = default;
  PolyM<P>& operator=(PolyM&& other) = default;

  PolyM<P>& adjust_leading_zeros() {
    int n = (int)data.size() - 1;
    while (n > 0 && data[n] == 0) --n;
    data.resize(max(n + 1, 1));
    return *this;
  }

  PolyM<P>& adjust_mod() {
    for (auto& iter : data) {
      iter = regulate_mod(iter, P);
    }
    return *this;
  }

  int deg() const { return static_cast<int>(data.size() - 1); }
  int size() const { return static_cast<int>(data.size());}

  PolyM<P>& resize(int n) {
    const int m = (int)data.size();
    data.resize(n);
    for (int i = m; i < n; ++i) {
      data[i] = 0;
    }
    return *this;
  }

  PolyM<P>& redeg(int n) { return resize(n+1);}

  int64& operator[](int idx) {
    PE_ASSERT(idx >= 0 && idx < data.size());
    return data[idx];
  }

  int64 operator[](int idx) const {
    PE_ASSERT(idx >= 0 && idx < data.size());
    return data[idx];
  }

  int64 at(int idx) const {
    return idx >= 0 && idx < data.size() ? data[idx] : 0;
  }

  bool isZero() const {
    return data.size() == 1 && data[0] == 0;
  }
  
  int64 valueAt(int64 v) {
    int64 ret = 0;
    for (int i = deg(); i >= 0; --i) {
      ret = ret * v % P + data[i];
      if (ret >= P) ret -= P;
    }
    return ret;
  }

  PolyM<P> lower_terms(int n) const {
    const int m = min(n, static_cast<int>(data.size()));
    return PolyM<P>(std::vector<int64>(data.begin(), data.begin() + m));
  }

  PolyM<P> inv(int n) const;
};

// Mul two polynomials with the same length.
// Make sure the length of result is at least: n + n
// The return length is 2n (not 2n-1)
template<typename T>
SL
REQUIRES((is_native_integer<T>::value))
RETURN(void)
poly_mul_normal_internal(const T* X, const T* Y, const int n, T* result, int64 mod) {
  const int n2 = n << 1;
  if (n <= 49) {
    fill(result, result+n2, 0);
    for (int i = 0; i < n; ++i)
      for (int j = 0; j < n; ++j) {
        result[i+j] = add_mod(result[i+j], (typename AtLeastUint64<T>::type)X[i] * Y[j] % mod, mod);
      }
    return;
  }

  const int m1 = n + 1 >> 1;
  const int m0 = n - m1;
  const int dbm1 = m1 << 1;
  const int dbm0 = m0 << 1;
  //m1 >= m0
  const T* x0 = X + m1;
  const T* y0 = Y + m1;
  const T* x1 = X;
  const T* y1 = Y;

  T* x0y0 = new T[dbm1];
  T* x1y1 = new T[dbm1];
  #pragma omp parallel sections if (n > 5000)
  {
    #pragma omp section
    poly_mul_normal_internal(x0, y0, m0, x0y0, mod);
    #pragma omp section
    poly_mul_normal_internal(x1, y1, m1, x1y1, mod);
  }
  if (m0 != m1) {
    x0y0[dbm0] = 0;
    x0y0[dbm0+1] = 0;
  }
  T* w = new T[dbm1];
  {
    T* u = new T[m1];
    T* v = new T[m1];

    for (int i = 0; i < m0; ++i)
      u[i] = add_mod(x0[i], x1[i], mod),
      v[i] = add_mod(y0[i], y1[i], mod);
    if (m0 != m1) {
      u[m1-1] = x1[m1-1];
      v[m1-1] = y1[m1-1];
    }
    poly_mul_normal_internal(u, v, m1, w, mod);
    delete[] u;
    delete[] v;
    for (int i = 0; i < m1*2; ++i)
      w[i] = sub_mod(w[i], add_mod(x0y0[i], x1y1[i], mod), mod);
  }
  fill(result, result + n2, 0);
  for (int i = 0; i < dbm0; ++i)
    result[dbm1+i] = add_mod(result[dbm1+i], x0y0[i], mod);
  for (int i = 0; i < dbm1; ++i)
    result[m1+i] = add_mod(result[m1+i], w[i], mod);
  for (int i = 0; i < dbm1; ++i)
    result[i] = add_mod(result[i], x1y1[i], mod);
  delete[] x0y0;
  delete[] x1y1;
  delete[] w;
}

// Multiply two polynomials.
// Make sure the length of result is at least: n + m - 1
template<typename T>
SL
REQUIRES((is_native_integer<T>::value))
RETURN(void)
poly_mul_normal(const T* X, const int n, const T* Y, const int m, T* result, int64 mod) {
  typedef typename std::make_unsigned<T>::type unsignedT;
  // In case n == m, we still allocate tempory result space to meet the
  // requirement of poly_mul_normal_internal.
  const int v = max(n, m);
  vector<T> tresult(v*2);
  if (n < m) {
    vector<T> XX(2*v);
    for (int i = 0; i < n; ++i) {
      XX[i] = X[i];
    }
    for (int i = n; i < m; ++i) {
      XX[i] = 0;
    }
    poly_mul_normal_internal<unsignedT>((const unsignedT*)&XX[0], (const unsignedT*)Y, m, (unsignedT*)&tresult[0], mod);
  } else {
    vector<T> YY(2*v);
    for (int i = 0; i < m; ++i) {
      YY[i] = Y[i];
    }
    for (int i = m; i < n; ++i) {
      YY[i] = 0;
    }
    poly_mul_normal_internal<unsignedT>((const unsignedT*)X, (const unsignedT*)&YY[0], n, (unsignedT*)&tresult[0], mod);
  }
  copy(tresult.begin(), tresult.begin() + n + m - 1, result);
}

template<typename T>
SL
REQUIRES((is_native_integer<T>::value))
RETURN(vector<T>)
poly_mul_normal(const vector<T>& X, const vector<T>& Y, int64 mod) {
  const int n = X.size();
  const int m = Y.size();
  const int resultSize = n + m - 1;
  typedef typename std::make_unsigned<T>::type unsignedT;
  if (n == m) {
    vector<T> result(2*n);
    poly_mul_normal_internal<unsignedT>((const unsignedT*)&X[0], (const unsignedT*)&Y[0], n, (unsignedT*)&result[0], mod);
    result.resize(resultSize);
    return result;
  } else if (n > m) {
    vector<T> YY;
    vector<T> result(2*n);
    YY.resize(n);
    for (int i = 0; i < m; ++i)
      YY[i] = Y[i];
    poly_mul_normal_internal<unsignedT>((const unsignedT*)&X[0], (const unsignedT*)&YY[0], n, (unsignedT*)&result[0], mod);
    result.resize(resultSize);
    return result;
  } else {
    vector<T> XX;
    vector<T> result(2*m);
    XX.resize(m);
    for (int i = 0; i < n; ++i)
      XX[i] = X[i];
    poly_mul_normal_internal<unsignedT>((const unsignedT*)&XX[0], (const unsignedT*)&Y[0], m, (unsignedT*)&result[0], mod);
    result.resize(resultSize);
    return result;
  }
}

template<int64 P>
SL PolyM<P> poly_mul_normal(const PolyM<P>& X, const PolyM<P>& Y) {
  auto data = poly_mul(X.data, Y.data, P);
  return PolyM<P>{std::move(data)};
}

// Need int128 to handle the big polynomial coefficient.
#if PE_HAS_INT128
#define HAS_POLY_MUL_NTT 1

// Multiply two polynomials.
// Make sure the length of result is at least: n + m - 1
template<typename T>
SL
REQUIRES((is_native_integer<T>::value))
RETURN(void)
poly_mul_ntt_internal(const T* X, int n, const T* Y, int m, T* result, int64 mod) {
  static_assert(std::is_unsigned<T>::value, "T must be unsigned");

  int alignedSize = 1;
  while (alignedSize < n + m) alignedSize <<= 1;

  // TODO(baihacker): decide the size automatically.
  NttMod moder[3] = {nttMod1, nttMod2, nttMod3};
  vector<uint64> tresult[3];
  #pragma omp parallel for schedule(dynamic, 1) num_threads(3)
  for (int id = 0; id < 3; ++id) {
    vector<uint64> XX(alignedSize);
    vector<uint64> YY(alignedSize);
    for (int i = 0; i < n; ++i) XX[i] = X[i];
    for (int i = n; i < alignedSize; ++i) XX[i] = 0;
    for (int i = 0; i < m; ++i) YY[i] = Y[i];
    for (int i = m; i < alignedSize; ++i) YY[i] = 0;
    #pragma omp parallel sections if (n + m >= 100000)
    {
      #pragma omp section
      ntt(&XX[0], alignedSize, moder[id]);
      #pragma omp section
      ntt(&YY[0], alignedSize, moder[id]);
    }
    const uint64 mod = moder[id].mod;
    for (int i = 0; i < alignedSize; ++i) {
      XX[i] = (uint64)XX[i] * YY[i] % mod;
    }
    ntt(&XX[0], alignedSize, moder[id], true);
    tresult[id] = std::move(XX);
  }

  const int resultSize = n + m - 1;
  int128 mods[3] = {nttMod1.mod, nttMod2.mod, nttMod3.mod};
  #pragma omp parallel for schedule(dynamic, 100000) if (n + m >= 100000)
  for (int i = 0; i < resultSize; ++i) {
    int128 val[3] = {tresult[0][i], tresult[1][i], tresult[2][i]};
    int128 have, v, u;
    tie(have, v, u) = crtn<int128>(val, mods, 3);
    result[i] = v % mod;
  }
}

// Multiply two polynomials.
// The length of result is at least n + m - 1.
template<typename T>
SL
REQUIRES((is_native_integer<T>::value))
RETURN(void)
poly_mul_ntt(const T* X, const int n, const T* Y, const int m, T* result, int64 mod) {
  typedef typename std::make_unsigned<T>::type unsignedT;
  poly_mul_ntt_internal<unsignedT>((const unsignedT*)X, n, (const unsignedT*)Y, m, (unsignedT*)result, mod);
}

template<typename T>
SL
REQUIRES((is_native_integer<T>::value))
RETURN(vector<T>)
poly_mul_ntt(const vector<T>& X, const vector<T>& Y, int64 mod) {
  const int n = (int)X.size() - 1;
  const int m = (int)Y.size() - 1;

  vector<T> result(n + m + 1);
  poly_mul_ntt(&X[0], n + 1, &Y[0], m + 1, &result[0], mod);

  return result;
}

template<int64 P>
SL PolyM<P> poly_mul_ntt(const PolyM<P>& X, const PolyM<P>& Y) {
  auto data = poly_mul_ntt(X.data, Y.data, P);
  return PolyM<P>{std::move(data)};
}
#else
#define HAS_POLY_MUL_NTT 0
#endif

template<typename T>
SL
REQUIRES((is_native_integer<T>::value))
RETURN(void)
poly_mul(const T* X, const int n, const T* Y, const int m, T* result, int64 mod) {
  typedef typename std::make_unsigned<T>::type unsignedT;

  #if HAS_POLY_MUL_NTT
    const int c = max(n, m);
    c >= 50 ? poly_mul_ntt(&X[0], n, &Y[0], m, result, mod) : 
  #endif
  poly_mul_normal(&X[0], n, &Y[0], m, result, mod);
}

template<typename T>
SL
REQUIRES((is_native_integer<T>::value))
RETURN(vector<T>)
poly_mul(const vector<T>& X, const vector<T>& Y, int64 mod) {
  const int n = (int)X.size() - 1;
  const int m = (int)Y.size() - 1;

  vector<T> result(n + m + 1);
  poly_mul(&X[0], n + 1, &Y[0], m + 1, &result[0], mod);

  return result;
}

template<typename T>
SL
REQUIRES((is_native_integer<T>::value))
RETURN(void)
poly_inv_internal(int n, const T* a, T* b, T* tmp[2], int64 mod) {
  static_assert(std::is_unsigned<T>::value, "T must be unsigned");
  if (n == 1) {
    b[0] = power_mod(a[0], mod - 2, mod);
  } else {
    poly_inv_internal(n + 1 >> 1, a, b, tmp, mod);

    int p = 1;
    while (p < n << 1) p <<= 1;
    poly_mul(b, n, b, n, tmp[0], mod);
    poly_mul(a, n, tmp[0], n, tmp[1], mod);
    for (int i = 0; i < n; ++i) {
      auto t = b[i] << 1;
      if (t >= mod) t -= mod;
      t = t + mod - tmp[1][i];
      if (t >= mod) t -= mod;
      b[i] = t;
    }
    fill(b + n, b + p, 0);
  }
}

template<typename T>
SL
REQUIRES((is_native_integer<T>::value))
RETURN(void)
poly_inv_mod(const T* x, int m, int n, T* result, int64 mod) {
  // It is assumed that mod is a prime
  const int t = max(n, m);
  int p = 1;
  while (p < t << 1) p <<= 1;

  // a
  vector<T> a(p);
  for (int i = 0; i < m; ++i) {
    a[i] = x[i];
  }
  for (int i = m; i < p; ++i) {
    a[i] = 0;
  }

  // b
  vector<T> b(p);

  // tmp
  vector<T> tmpData[2];
  T* tmp[2];
  for (int i = 0; i < 2; ++i) {
    tmpData[i].resize(p);
    tmp[i] = &tmpData[i][0];
  }

  poly_inv_internal(n, &a[0], &b[0], tmp, mod);
  copy(b.begin(), b.begin() + n, result);
}

template<typename T>
SL
REQUIRES((is_native_integer<T>::value))
RETURN(vector<T>)
poly_inv_mod(const vector<T>& x, int n, int64 mod) {
  // It is assumed that mod is a prime
  const int m = x.size();
  const int t = max(n, m);
  int p = 1;
  while (p < t << 1) p <<= 1;

  // b
  vector<T> b(p);
  
  poly_inv_mod(&x[0], m, n, &b[0], mod);
  b.resize(n);
  return b;
}

// size r >= m
// size q >= n - m + 1
template<typename T>
SL
REQUIRES((is_native_integer<T>::value))
RETURN(void)
poly_div_dc_internal(const T* X, int n, const T* Y, int m, T* q, T* r, int64 mod) {
  static_assert(std::is_unsigned<T>::value, "T must be unsigned");
  if (m > n) {
    copy(X, X+n, r);
    fill(r+m, r+n, 0);
    q[0] = 0;
    return;
  }
  vector<T> YR(m);
  for (int i = 0; i < m; ++i) YR[i] = Y[m-1-i];
  vector<T> IYR = poly_inv_mod(YR, n - m + 1, mod);
  vector<T> XR(n);
  for (int i = 0; i < n; ++i) XR[i] = X[n-1-i];
  vector<T> Z = poly_mul(XR, IYR, mod);
  Z.resize(n - m + 1);
  reverse(Z.begin(), Z.end());
  copy(Z.begin(), Z.end(), q);
  vector<T> tmp(n);
  poly_mul(&Y[0], m, &Z[0], n-m+1, &tmp[0], mod);
  for (int i = 0; i < m; ++i) {
    r[i] = X[i] >= tmp[i] ? X[i] - tmp[i] : X[i] + mod - tmp[i];
  }
}

// size r >= m
// size q >= n - m + 1
template<typename T>
SL
REQUIRES((is_native_integer<T>::value))
RETURN(void)
poly_div_dc(const T* X, const int n, const T* Y, const int m, T* q, T* r, int64 mod) {
  typedef typename std::make_unsigned<T>::type unsignedT;
  poly_div_dc_internal<unsignedT>((const unsignedT*)X, n, (const unsignedT*)Y, m, (unsignedT*)q, (unsignedT*)r, mod);
}

// deg q = max(deg X - degY + 1, 1)
// deg r <= deg x - deg y
template<typename T>
SL
REQUIRES((is_native_integer<T>::value))
RETURN(tuple<vector<T>, vector<T>>)
poly_div_dc(const vector<T>& X, const vector<T>& Y, int64 mod) {
  const int n = (int)X.size() - 1;
  const int m = (int)Y.size() - 1;

  vector<T> q(max(n - m + 1, 1));
  vector<T> r(m+1);
  poly_div_dc(&X[0], n + 1, &Y[0], m + 1, &q[0], &r[0], mod);

  int t = m;
  r[m] = 0;
  while (t >= 0 && r[t] == 0) --t;
  r.resize(t+1);
  return make_tuple(std::move(q), std::move(r));
}

// deg q = max(deg X - degY + 1, 1)
// deg r <= deg x - deg y
template<int64 P>
SL tuple<PolyM<P>, PolyM<P>> poly_div_dc(const PolyM<P>& X, const PolyM<P>& Y) {
  vector<int64> q, r;
  tie(q, r) = poly_mod_dc(X.data, Y.data, P);
  return make_tuple(std::move(PolyM<P>(q)), PolyM<P>(std::move(r)));
}

// size r >= m
// size q >= n - m + 1
template<typename T>
SL
REQUIRES((is_native_integer<T>::value))
RETURN(void)
poly_div_normal_internal(const T* X, int n, const T* Y, int m, T* q, T* r, int64 mod) {
  if (m > n) {
    copy(X, X+n, r);
    fill(r+m, r+n, 0);
    q[0] = 0;
    return;
  }

  int top = 0;
  vector<T> tmp(X, X+n);
  int64 t = inv_of(Y[m-1], mod);
  for (int i = n - 1; i >= m - 1; --i) {
    int64 u = tmp[i] * t % mod;
    for (int j = i, k = m - 1; k >= 0; --j, --k) {
      tmp[j] = sub_mod(tmp[j], u * Y[k] % mod, mod);
    }
    q[top++] = u;
  }
  reverse(q, q + top);
  copy(tmp.begin(), tmp.begin() + m, r);
}

template<typename T>
SL
REQUIRES((is_native_integer<T>::value))
RETURN(void)
poly_div_normal(const T* X, const int n, const T* Y, const int m, T* q, T* r, int64 mod) {
  typedef typename std::make_unsigned<T>::type unsignedT;
  poly_div_normal_internal<unsignedT>((const unsignedT*)X, n, (const unsignedT*)Y, m, (unsignedT*)q, (unsignedT*)r, mod);
}

template<typename T>
SL
REQUIRES((is_native_integer<T>::value))
RETURN(tuple<vector<T>, vector<T>>)
poly_div_normal(const vector<T>& X, const vector<T>& Y, int64 mod) {
  const int n = (int)X.size() - 1;
  const int m = (int)Y.size() - 1;

  vector<T> q(max(n - m + 1, 1));
  vector<T> r(m+1);
  poly_div_normal(&X[0], n + 1, &Y[0], m + 1, &q[0], &r[0], mod);

  int t = m;
  r[m] = 0;
  while (t >= 0 && r[t] == 0) --t;
  r.resize(t+1);
  return make_tuple(std::move(q), std::move(r));
}

template <int64 P>
SL tuple<PolyM<P>, PolyM<P>> poly_div_normal(const PolyM<P>& x, const PolyM<P>& y) {
  vector<int64> q, r;
  tie(q, r) = poly_mod_dc(x.data, y.data, P);
  return poly_div_normal(std::move(PolyM<P>(q)), PolyM<P>(std::move(r)));
}

template<typename T>
SL
REQUIRES((is_native_integer<T>::value))
RETURN(void)
poly_div(const T* X, const int n, const T* Y, const int m, T* q, T* r, int64 mod) {
  typedef typename std::make_unsigned<T>::type unsignedT;
  // choose algorithm
  poly_div_dc_internal<unsignedT>((const unsignedT*)X, n, (const unsignedT*)Y, m, (unsignedT*)q, (unsignedT*)r, mod);
}

template<typename T>
SL
REQUIRES((is_native_integer<T>::value))
RETURN(tuple<vector<T>, vector<T>>)
poly_div(const vector<T>& X, const vector<T>& Y, int64 mod) {
  const int n = (int)X.size() - 1;
  const int m = (int)Y.size() - 1;

  vector<T> q(max(n - m + 1, 1));
  vector<T> r(m+1);
  poly_div(&X[0], n + 1, &Y[0], m + 1, &q[0], &r[0], mod);

  int t = m;
  r[m] = 0;
  while (t >= 0 && r[t] == 0) --t;
  r.resize(t+1);
  return make_tuple(std::move(q), std::move(r));
}

template <int64 P>
SL tuple<PolyM<P>, PolyM<P>> poly_div(const PolyM<P>& x, const PolyM<P>& y) {
  vector<int64> q, r;
  tie(q, r) = poly_mod_dc(x.data, y.data, P);
  return poly_div(std::move(PolyM<P>(q)), PolyM<P>(std::move(r)));
}

struct PSPTree {
  int64 mod;
  
  int64* v;
  int n;
  
  vector<int64> p;

  PSPTree* L;
  PSPTree* R;
  
  ~PSPTree() {
    if (L) delete L;
    if (R) delete R;
  }
  
  static PSPTree* build_minus(int64* values, int n, int64 mod) {
    PSPTree* ptree = new PSPTree();
    auto& tree = *ptree;
    tree.mod = mod;
    tree.v = values;
    tree.n = n;
    tree.L = tree.R = NULL;
    if (n == 1) {
      // -x0 + x
      int64 t = values[0];
      tree.p.emplace_back(t == 0 ? 0 : mod - t);
      tree.p.emplace_back(1%mod);
      return ptree;
    }
    int c1 = n >> 1, c2 = n - c1;
    tree.L = build_minus(values, c1, mod);
    tree.R = build_minus(values+c1, c2, mod);
    tree.p = poly_mul_ntt(tree.L->p, tree.R->p, mod);
    return ptree;
  }

  static PSPTree* build_plus(int64* values, int n, int64 mod) {
    PSPTree* ptree = new PSPTree();
    auto& tree = *ptree;
    tree.mod = mod;
    tree.v = values;
    tree.n = n;
    tree.L = tree.R = NULL;
    if (n == 1) {
      // x0 + x
      int64 t = values[0];
      tree.p.emplace_back(t);
      tree.p.emplace_back(1);
      return ptree;
    }
    int c1 = n >> 1, c2 = n - c1;
    tree.L = build_plus(values, c1, mod);
    tree.R = build_plus(values+c1, c2, mod);
    tree.p = poly_mul_ntt(tree.L->p, tree.R->p, mod);
    return ptree;
  }
};

// size(V) = n
template<typename T>
SL
REQUIRES((is_native_integer<T>::value))
RETURN(void)
poly_evaluate_mod_internal_impl(const T* X, int n, PSPTree* psp, T* result, int64 mod) {
  if (psp->n == 1) {
    result[0] = (X[0] + psp->v[0] * X[1]) % mod;
    return;
  }
  int c1 = psp->n >> 1;
  int c2 = psp->n - c1;

  vector<T> m(max(psp->L->p.size(), psp->R->p.size()));
  poly_mod(X, n, (const T*)&psp->L->p[0], psp->L->p.size(), &m[0], mod);
  poly_evaluate_mod_internal_impl(&m[0], (int)psp->L->p.size()-1, psp->L, result, mod);
  poly_mod(X, n, (const T*)&psp->R->p[0], psp->R->p.size(), &m[0], mod);
  poly_evaluate_mod_internal_impl(&m[0], (int)psp->R->p.size()-1, psp->R, result+c1, mod);
}

// size(V) = n
template<typename T>
SL
REQUIRES((is_native_integer<T>::value))
RETURN(void)
poly_evaluate_mod_internal(const T* X, int n, const T* V, T* result, int64 mod) {
  static_assert(std::is_unsigned<T>::value, "T must be unsigned");
  PSPTree* psp = PSPTree::build_minus((int64*)V, n, mod);
  poly_evaluate_mod_internal_impl(X, n, psp, result, mod);
  delete psp;
}

// size(V) = n
template<typename T>
SL
REQUIRES((is_native_integer<T>::value))
RETURN(void)
poly_evaluate_mod_internal_ex(const T* X, int n, const T* V, T* result, int64 mod) {
  static_assert(std::is_unsigned<T>::value, "T must be unsigned");
  vector<vector<vector<T>>> tree;
  {
    vector<vector<T>> from;
    for (int i = 0; i < n; ++i) {
      vector<T> tmp{(V[i] == 0 ? 0 : mod - V[i])%mod, 1};
      from.push_back(tmp);
    }

    tree.push_back(from);
    int lastSize = n;
    while (lastSize != 1) {
      vector<vector<T>> to;
      for (int i = 0; i < lastSize / 2; ++i) {
        to.push_back(poly_mul_auto(from[i*2], from[i*2+1], mod));
      }
      if (lastSize&1) {
        to.push_back(from[lastSize-1]);
      }
      lastSize = lastSize + 1 >> 1;
      from.swap(to);
      tree.push_back(from);
    }
  }
  
  const int d = (int)tree.size() - 1;
  {
    auto alpha = tree[d][0];
    reverse(alpha.begin(), alpha.end());
    alpha = poly_inv_mod(&alpha[0], alpha.size(), n, mod);
    // size alpha = n
    reverse(alpha.begin(), alpha.end());
    vector<uint64> b(X, X+n);
    int degb = sz(b) - 1;
    auto t = poly_mul_auto(alpha, b, mod);
    // deg t = (n - 1) + degb
    assert(sz(t) - 1 == n - 1 + degb);
    for (int i = n - 1, j = 0; i <= (n-1) + degb; ++i, ++j) {
      t[j] = t[i];
    }
    assert(degb + 1 >= n);
    t.resize(n);
    reverse(t.begin(), t.end());
    vector<vector<T>> c(n);
    c[0] = t;
    //c[0] = vector<uint64>(X, X+n);
    for (int i = d; i > 0; --i) {
      int hi = tree[i].size();
      for (int j = hi - 1; j >= 0; --j) {
        int u = j * 2;
        int v = u + 1;
        if (v >= tree[i-1].size()) {
          c[u] = c[j];
          continue;
        }
        int nn = tree[i][j].size() - 1;
        vector<T> x;
        {
          const int os = sz(tree[i-1][2*j]);
          reverse(tree[i-1][2*j].begin(), tree[i-1][2*j].end());
          x = poly_mul_auto(tree[i-1][2*j], c[j], mod);
          int s = 0;
          for (int i = os - 1, j = 0; i < x.size() && j < nn; ++i, ++j) {
            x[j] = x[i];
            ++s;
          }
          x.resize(s);
        }
        vector<T> y;
        {
          const int os = sz(tree[i-1][2*j+1]);
          reverse(tree[i-1][2*j+1].begin(), tree[i-1][2*j+1].end());
          y = poly_mul_auto(tree[i-1][2*j+1], c[j], mod);
          int s = 0;
          for (int i = os - 1, j = 0; i < y.size() && j < nn; ++i, ++j) {
            y[j] = y[i];
            ++s;
          }
          y.resize(s);
        }
        c[2*j+1] = std::move(x);
        c[2*j] = std::move(y);
      }
    }
    for (int i = 0; i < n; ++i) result[i] = c[i][0];
  }
}

// size(V) = n
template<typename T>
SL
REQUIRES((is_native_integer<T>::value))
RETURN(void)
poly_evaluate_mod(const T* X, const int n, const T* V, T* result, int64 mod) {
  typedef typename std::make_unsigned<T>::type unsignedT;
  poly_evaluate_mod_internal_ex<unsignedT>((const unsignedT*)X, n, (const unsignedT*)V, (unsignedT*)result, mod);
}

// size x = size v
template<typename T>
SL
REQUIRES((is_native_integer<T>::value))
RETURN(vector<T>)
poly_evaluate_mod(const vector<T>& X, const vector<T>& V, int64 mod) {
  const int n = (int)X.size();
  vector<T> result(n);
  poly_evaluate_mod(&X[0], n, &V[0], &result[0], mod);
  return result;
}

// size x = size v
template<int64 P>
SL vector<int64> poly_evaluate_mod(const PolyM<P>& X, const vector<int64>& V) {
  return poly_evaluate_mod(X.data, V, P);
}

template<int64 P>
inline PolyM<P> PolyM<P>::inv(int n) const {
  // It is assumed that mod is a prime
  auto t = poly_inv_mod(data, n, P);
  return PolyM<P>(std::vector<int64>((int64*)&t[0], (int64*)&t[0] + t.size()));
}

template <int64 P>
PolyM<P> operator<<(const PolyM<P>& p, int m) {
  if (m == 0) {
    return p;
  }
  std::vector<int64> new_data(p.data.size() + m);
  for (int i = static_cast<int>(p.data.size()) + m - 1; i >= m; --i) {
    new_data[i] = p.data[i - m];
  }
  for (int i = 0; i < m; ++i) {
    new_data[i] = 0;
  }
  return PolyM<P>(std::move(new_data));
}

template <int64 P>
SL PolyM<P> operator-(const PolyM<P>& x, const PolyM<P>& y) {
  const int n = max(x.deg(), y.deg());
  std::vector<int64> data(n + 1);
  for (int i = 0; i <= n; ++i) {
    data[i] = sub_mod(x.at(i), y.at(i), P);
  }
  return PolyM<P>(std::move(data)).adjust_leading_zeros();
}

template <int64 P>
SL PolyM<P> operator+(const PolyM<P>& x, const PolyM<P>& y) {
  const int n = max(x.deg(), y.deg());
  std::vector<int64> data(n + 1);
  for (int i = 0; i <= n; ++i) {
    data[i] = add_mod(x.at(i), y.at(i), P);
  }
  return PolyM<P>(std::move(data)).adjust_leading_zeros();
}

template <int64 P>
SL PolyM<P> operator*(const PolyM<P>& x, int64 v) {
  std::vector<int64> data(x.data);
  for (auto& iter : data) {
    iter = iter * v % P;
  }
  return PolyM<P>(std::move(data));
}

template <int64 P>
SL PolyM<P> operator*(int64 v, const PolyM<P>& x) {
  return x * v;
}

template <int64 P>
SL PolyM<P> operator/(const PolyM<P>& x, const PolyM<P>& y) {
  PolyM<P> q, r;
  tie(q, r) = poly_div(x, y);
  return r;
}

template <int64 P>
SL PolyM<P> operator%(const PolyM<P>& x, const PolyM<P>& y) {
  PolyM<P> q, r;
  tie(q, r) = poly_div(x, y);
  return r;
}

// x^n % mod
template <int64 P>
SL PolyM<P> operator%(int64 n, PolyM<P> mod) {
  PolyM<P> x{0, 1};
  PolyM<P> ret{1};
  for (; n > 0; n >>= 1) {
    if (n & 1) {
      auto t = x * ret;
      PolyM<P> q, r;
      tie(q, r) = div(t, mod);
      ret = std::move(r);
    }
    if (n > 1) {
      auto t = x * x;
      PolyM<P> q, r;
      tie(q, r) = div(t, mod);
      x = r;
    }
  }
  return ret;
}

template <int64 P>
SL ostream& operator<<(ostream& o, const PolyM<P>& p) {
  const int n = p.data.size();
  for (int i = 0; i < n - 1; ++i) {
    o << p.data[i] << ", ";
  }
  return o << p.data[n - 1];
}

#if 1
template <int64 P>
SL PolyM<P> operator*(const PolyM<P>& x, const PolyM<P>& y) {
  return poly_mul(x, y);
}
#else
template <int64 P>
SL PolyM<P> operator*(const PolyM<P>& x, const PolyM<P>& y) {
  const int n = x.deg();
  const int m = y.deg();
  std::vector<int64> data(n + m + 1, 0);
  for (int i = 0; i <= n; ++i)
    for (int j = 0; j <= m; ++j) {
      int64 t = x[i] * y[j] % P;
      data[i + j] = add_mod(data[i + j], t, P);
    }
  return PolyM<P>(std::move(data));
}
#endif



#endif

#include "pe_poly_app"