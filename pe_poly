#ifndef __PE_POLY__
#define __PE_POLY__

#include "pe_base"
#include "pe_int128"
#include "pe_mod"
#include "pe_ntt"
#include "pe_type_traits"
#include "pe_nt"

template <typename T>
SL void adjust_poly_leading_zero(vector<T>& v) {
  int now = (int)v.size() - 1;
  while (now > 0 && v[now] == 0) --now;
  v.resize(now + 1);
}

template <typename T>
SL REQUIRES((is_native_integer<T>::value)) RETURN(void)
    poly_add(const T* X, const int n, const T* Y, const int m, T* result,
             int64 mod) {
  if (n <= m) {
    for (int i = 0; i < n; ++i) {
      result[i] = add_mod(X[i], Y[i], mod);
    }
    copy(Y + n, Y + m, result + n);
  } else {
    for (int i = 0; i < m; ++i) {
      result[i] = add_mod(X[i], Y[i], mod);
    }
    copy(X + m, X + n, result + m);
  }
}

template <typename T>
SL REQUIRES((is_native_integer<T>::value)) RETURN(vector<T>)
    poly_add(const vector<T>& X, const vector<T>& Y, int64 mod) {
  const int n = (int)X.size();
  const int m = (int)Y.size();

  vector<T> result(max(n, m));
  poly_add(&X[0], n, &Y[0], m, &result[0], mod);

  return result;
}

template <typename T>
SL REQUIRES((is_native_integer<T>::value)) RETURN(void)
    poly_sub(const T* X, const int n, const T* Y, const int m, T* result,
             int64 mod) {
  if (n <= m) {
    for (int i = 0; i < n; ++i) {
      result[i] = sub_mod(X[i], Y[i], mod);
    }
    for (int i = n; i < m; ++i) {
      result[i] = Y[i] == 0 ? 0 : mod - Y[i];
    }
  } else {
    for (int i = 0; i < m; ++i) {
      result[i] = sub_mod(X[i], Y[i], mod);
    }
    copy(X + m, X + n, result + m);
  }
}

template <typename T>
SL REQUIRES((is_native_integer<T>::value)) RETURN(vector<T>)
    poly_sub(const vector<T>& X, const vector<T>& Y, int64 mod) {
  const int n = (int)X.size();
  const int m = (int)Y.size();

  vector<T> result(max(n, m));
  poly_sub(&X[0], n, &Y[0], m, &result[0], mod);

  return result;
}

// Multiply two polynomials of the same length.
// size result >= 2 * n
// size return = 2 * n (deg return = 2 * n - 1)
template <typename T>
SL REQUIRES((is_native_integer<T>::value)) RETURN(void)
    poly_mul_normal_internal(const T* X, const T* Y, const int n, T* result,
                             int64 mod) {
  static_assert(std::is_unsigned<T>::value, "T must be unsigned");

  const int n2 = n << 1;
  if (n <= 49) {
    fill(result, result + n2, 0);
    for (int i = 0; i < n; ++i)
      for (int j = 0; j < n; ++j) {
        result[i + j] =
            add_mod(result[i + j], mul_mod_ex(X[i], Y[j], mod), mod);
      }
    return;
  }

  const int m1 = (n + 1) >> 1;
  const int m0 = n - m1;
  const int dbm1 = m1 << 1;
  const int dbm0 = m0 << 1;
  // m1 >= m0
  const T* x0 = X + m1;
  const T* y0 = Y + m1;
  const T* x1 = X;
  const T* y1 = Y;

  T* x0y0 = new T[dbm1];
  T* x1y1 = new T[dbm1];
#if ENABLE_OPENMP
#pragma omp parallel sections if (n > 5000)
#endif
  {
#if ENABLE_OPENMP
#pragma omp section
#endif
    poly_mul_normal_internal(x0, y0, m0, x0y0, mod);
#if ENABLE_OPENMP
#pragma omp section
#endif
    poly_mul_normal_internal(x1, y1, m1, x1y1, mod);
  }
  if (m0 != m1) {
    x0y0[dbm0] = 0;
    x0y0[dbm0 + 1] = 0;
  }
  T* w = new T[dbm1];
  {
    T* u = new T[m1];
    T* v = new T[m1];

    for (int i = 0; i < m0; ++i)
      u[i] = add_mod(x0[i], x1[i], mod), v[i] = add_mod(y0[i], y1[i], mod);
    if (m0 != m1) {
      u[m1 - 1] = x1[m1 - 1];
      v[m1 - 1] = y1[m1 - 1];
    }
    poly_mul_normal_internal(u, v, m1, w, mod);
    delete[] u;
    delete[] v;
    for (int i = 0; i < m1 * 2; ++i)
      w[i] = sub_mod(w[i], add_mod(x0y0[i], x1y1[i], mod), mod);
  }
  fill(result, result + n2, 0);
  for (int i = 0; i < dbm0; ++i)
    result[dbm1 + i] = add_mod(result[dbm1 + i], x0y0[i], mod);
  for (int i = 0; i < dbm1; ++i)
    result[m1 + i] = add_mod(result[m1 + i], w[i], mod);
  for (int i = 0; i < dbm1; ++i) result[i] = add_mod(result[i], x1y1[i], mod);
  delete[] x0y0;
  delete[] x1y1;
  delete[] w;
}

// Multiply two polynomials.
// size result >= n + m - 1
template <typename T>
SL REQUIRES((is_native_integer<T>::value)) RETURN(void)
    poly_mul_normal(const T* X, const int n, const T* Y, const int m, T* result,
                    int64 mod) {
  typedef typename std::make_unsigned<T>::type unsignedT;
  // In case n == m, we still allocate tempory result space to meet the
  // requirement of poly_mul_normal_internal.
  const int v = max(n, m);
  vector<T> tresult(v * 2);
  if (n < m) {
    vector<T> XX(2 * v);
    for (int i = 0; i < n; ++i) {
      XX[i] = X[i];
    }
    for (int i = n; i < m; ++i) {
      XX[i] = 0;
    }
    poly_mul_normal_internal<unsignedT>((const unsignedT*)&XX[0],
                                        (const unsignedT*)Y, m,
                                        (unsignedT*)&tresult[0], mod);
  } else {
    vector<T> YY(2 * v);
    for (int i = 0; i < m; ++i) {
      YY[i] = Y[i];
    }
    for (int i = m; i < n; ++i) {
      YY[i] = 0;
    }
    poly_mul_normal_internal<unsignedT>((const unsignedT*)X,
                                        (const unsignedT*)&YY[0], n,
                                        (unsignedT*)&tresult[0], mod);
  }
  copy(tresult.begin(), tresult.begin() + n + m - 1, result);
}

template <typename T>
SL REQUIRES((is_native_integer<T>::value)) RETURN(vector<T>)
    poly_mul_normal(const vector<T>& X, const vector<T>& Y, int64 mod) {
  typedef typename std::make_unsigned<T>::type unsignedT;

  const int n = (int)X.size();
  const int m = (int)Y.size();
  const int resultSize = n + m - 1;
  if (n == m) {
    vector<T> result(2 * n);
    poly_mul_normal_internal<unsignedT>((const unsignedT*)&X[0],
                                        (const unsignedT*)&Y[0], n,
                                        (unsignedT*)&result[0], mod);
    result.resize(resultSize);
    return result;
  } else if (n > m) {
    vector<T> YY;
    vector<T> result(2 * n);
    YY.resize(n);
    for (int i = 0; i < m; ++i) YY[i] = Y[i];
    poly_mul_normal_internal<unsignedT>((const unsignedT*)&X[0],
                                        (const unsignedT*)&YY[0], n,
                                        (unsignedT*)&result[0], mod);
    result.resize(resultSize);
    return result;
  } else {
    vector<T> XX;
    vector<T> result(2 * m);
    XX.resize(m);
    for (int i = 0; i < n; ++i) XX[i] = X[i];
    poly_mul_normal_internal<unsignedT>((const unsignedT*)&XX[0],
                                        (const unsignedT*)&Y[0], m,
                                        (unsignedT*)&result[0], mod);
    result.resize(resultSize);
    return result;
  }
}

template <typename T>
SL REQUIRES((is_native_integer<T>::value)) RETURN(void)
    poly_mul(const T* X, const int n, const T* Y, const int m, T* result,
             int64 mod) {
  typedef typename std::make_unsigned<T>::type unsignedT;

  const int isBig = max(n, m) >= 50;
  if (isBig) {
#if HAS_POLY_MUL_FLINT
    ntt_flint::poly_mul_flint(&X[0], n, &Y[0], m, result, mod);
#elif HAS_POLY_MUL_MIN25_NTT
    ntt_min25::poly_mul_ntt(&X[0], n, &Y[0], m, result, mod);
#elif HAS_POLY_MUL_NTT32
    ntt32::poly_mul_ntt(&X[0], n, &Y[0], m, result, mod);
#elif HAS_POLY_MUL_NTT64
    ntt64::poly_mul_ntt(&X[0], n, &Y[0], m, result, mod);
#else

#if defined(COMPILER_GNU)
#warning "poly_mul may be very slow."
#else
#pragma message("poly_mul may be very slow.")
#endif

    poly_mul_normal(&X[0], n, &Y[0], m, result, mod);
#endif
  } else {
    poly_mul_normal(&X[0], n, &Y[0], m, result, mod);
  }
}

template <typename T>
SL REQUIRES((is_native_integer<T>::value)) RETURN(vector<T>)
    poly_mul(const vector<T>& X, const vector<T>& Y, int64 mod) {
  const int n = (int)X.size();
  const int m = (int)Y.size();

  vector<T> result(n + m - 1);
  poly_mul(&X[0], n, &Y[0], m, &result[0], mod);

  return result;
}

template <typename T>
SL REQUIRES((is_native_integer<T>::value)) RETURN(void)
    poly_inv_mod_internal(int n, const T* a, T* b, T* tmp[2], int64 mod) {
  static_assert(std::is_unsigned<T>::value, "T must be unsigned");
  if (n == 1) {
    b[0] = power_mod_ex(a[0], mod - 2, mod);
  } else {
    const int m = (n + 1) >> 1;
    poly_inv_mod_internal(m, a, b, tmp, mod);
    fill(b + m, b + n, 0);
    poly_mul(b, m, b, m, tmp[0], mod);
    if (m + m - 2 < n - 1) {
      tmp[0][n - 1] = 0;
    }
    poly_mul(a, n, tmp[0], n, tmp[1], mod);
    for (int i = 0; i < n; ++i) {
      auto t = b[i] << 1;
      if (t >= static_cast<uint64>(mod)) t -= mod;
      t = t + mod - tmp[1][i];
      if (t >= static_cast<uint64>(mod)) t -= mod;
      b[i] = t;
    }
  }
}

// size result >= n
template <typename T>
SL REQUIRES((is_native_integer<T>::value)) RETURN(void)
    poly_inv_mod_internal(const T* x, int m, int n, T* result, int64 mod) {
  // It is assumed that mod is a prime
  const int t = max(n, m);
  const int p = 1 << pe_lg(4 * t - 1);

  // a
  vector<T> a(p);
  for (int i = 0; i < m; ++i) {
    a[i] = x[i];
  }
  for (int i = m; i < p; ++i) {
    a[i] = 0;
  }

  // b
  vector<T> b(n);

  // tmp
  vector<T> tmpData[2];
  T* tmp[2];
  for (int i = 0; i < 2; ++i) {
    tmpData[i].resize(p);
    tmp[i] = &tmpData[i][0];
  }

  poly_inv_mod_internal(n, &a[0], &b[0], tmp, mod);
  copy(b.begin(), b.begin() + n, result);
}

// size result >= n
template <typename T>
SL REQUIRES((is_native_integer<T>::value)) RETURN(void)
    poly_inv_mod(const T* x, int m, int n, T* result, int64 mod) {
  typedef typename std::make_unsigned<T>::type unsignedT;
  poly_inv_mod_internal<unsignedT>((const unsignedT*)x, m, n,
                                   (unsignedT*)result, mod);
}

template <typename T>
SL REQUIRES((is_native_integer<T>::value)) RETURN(vector<T>)
    poly_inv_mod(const vector<T>& x, int n, int64 mod) {
  // It is assumed that mod is a prime
  const int m = (int)x.size();
  const int t = max(n, m);
  const int p = 1 << pe_lg(4 * t - 1);

  // b
  vector<T> b(p);

  poly_inv_mod(&x[0], m, n, &b[0], mod);
  b.resize(n);
  return b;
}

// size r >= m
// size q >= n - m + 1
template <typename T>
SL REQUIRES((is_native_integer<T>::value)) RETURN(void)
    poly_div_and_mod_dc_internal(const T* X, int n, const T* Y, int m, T* q,
                                 T* r, int64 mod) {
  static_assert(std::is_unsigned<T>::value, "T must be unsigned");

  if (m > n) {
    if (r) {
      copy(X, X + n, r);
      fill(r + n, r + m, 0);
    }
    if (q) {
      q[0] = 0;
    }
    return;
  }
  vector<T> YR(m);
  for (int i = 0; i < m; ++i) YR[i] = Y[m - 1 - i];
  vector<T> IYR = poly_inv_mod(YR, n - m + 1, mod);
  vector<T> XR(n);
  for (int i = 0; i < n; ++i) XR[i] = X[n - 1 - i];
  vector<T> Z = poly_mul(XR, IYR, mod);
  Z.resize(n - m + 1);
  reverse(Z.begin(), Z.end());
  if (q) {
    copy(Z.begin(), Z.end(), q);
  }
  if (r) {
    vector<T> tmp(n);
    poly_mul(&Y[0], m, &Z[0], n - m + 1, &tmp[0], mod);
    for (int i = 0; i < m; ++i) {
      r[i] = X[i] >= tmp[i] ? X[i] - tmp[i] : X[i] + mod - tmp[i];
    }
  }
}

// size q >= n - m + 1
// size r >= m
template <typename T>
SL REQUIRES((is_native_integer<T>::value)) RETURN(void)
    poly_div_and_mod_normal_internal(const T* X, int n, const T* Y, int m, T* q,
                                     T* r, int64 mod) {
  static_assert(std::is_unsigned<T>::value, "T must be unsigned");

  if (m > n) {
    if (r) {
      copy(X, X + n, r);
      fill(r + n, r + m, 0);
    }
    if (q) {
      q[0] = 0;
    }
    return;
  }

  int top = 0;
  vector<T> tmp(X, X + n);
  int64 t = inv_of(Y[m - 1], mod);
  for (int i = n - 1; i >= m - 1; --i) {
    int64 u = tmp[i] * t % mod;
    for (int j = i, k = m - 1; k >= 0; --j, --k) {
      tmp[j] = sub_mod(tmp[j], u * Y[k] % mod, mod);
    }
    if (q) {
      q[top++] = u;
    }
  }
  if (q) {
    reverse(q, q + top);
  }
  if (r) {
    copy(tmp.begin(), tmp.begin() + m, r);
  }
}

// For input:
// size q >= max(deg X - deg Y + 1, 1)
// size r >= m
// For output:
// deg q = max(deg X - deg Y + 1, 1)
// For C-style method: deg r = deg Y (with possible leading zeros)
// For C++ style method: deg r <= deg Y (the leading zeros are ignored)
#define POLY_DIV_AND_MOD_IMPL(poly_div_and_mod, poly_div_and_mod_internal)     \
  template <typename T>                                                        \
  SL REQUIRES((is_native_integer<T>::value)) RETURN(void)                      \
      poly_div_and_mod(const T* X, const int n, const T* Y, const int m, T* q, \
                       T* r, int64 mod) {                                      \
    typedef typename std::make_unsigned<T>::type unsignedT;                    \
    poly_div_and_mod_internal<unsignedT>((const unsignedT*)X, n,               \
                                         (const unsignedT*)Y, m,               \
                                         (unsignedT*)q, (unsignedT*)r, mod);   \
  }                                                                            \
                                                                               \
  template <typename T>                                                        \
  SL REQUIRES((is_native_integer<T>::value))                                   \
      RETURN(tuple<vector<T>, vector<T>>) poly_div_and_mod(                    \
          const vector<T>& X, const vector<T>& Y, int64 mod) {                 \
    const int n = (int)X.size() - 1;                                           \
    const int m = (int)Y.size() - 1;                                           \
                                                                               \
    vector<T> q(max(n - m + 1, 1));                                            \
    vector<T> r(m + 1);                                                        \
    poly_div_and_mod(&X[0], n + 1, &Y[0], m + 1, &q[0], &r[0], mod);           \
                                                                               \
    r[m] = 0;                                                                  \
    adjust_poly_leading_zero(r);                                               \
    return make_tuple(std::move(q), std::move(r));                             \
  }

#define POLY_DIV_IMPL(poly_div, poly_div_and_mod)                          \
  template <typename T>                                                    \
  SL REQUIRES((is_native_integer<T>::value)) RETURN(void) poly_div(        \
      const T* X, const int n, const T* Y, const int m, T* q, int64 mod) { \
    poly_div_and_mod(X, n, Y, m, q, (T*)NULL, mod);                        \
  }                                                                        \
                                                                           \
  template <typename T>                                                    \
  SL REQUIRES((is_native_integer<T>::value)) RETURN(vector<T>)             \
      poly_div(const vector<T>& X, const vector<T>& Y, int64 mod) {        \
    vector<T> q(max((int)X.size() - (int)Y.size() + 1, 1));                \
    poly_div(&X[0], (int)X.size(), &Y[0], (int)Y.size(), &q[0], mod);      \
    return std::move(q);                                                   \
  }

#define POLY_MOD_IMPL(poly_mod, poly_div_and_mod)                          \
  template <typename T>                                                    \
  SL REQUIRES((is_native_integer<T>::value)) RETURN(void) poly_mod(        \
      const T* X, const int n, const T* Y, const int m, T* r, int64 mod) { \
    poly_div_and_mod(X, n, Y, m, (T*)NULL, r, mod);                        \
  }                                                                        \
                                                                           \
  template <typename T>                                                    \
  SL REQUIRES((is_native_integer<T>::value)) RETURN(vector<T>)             \
      poly_mod(const vector<T>& X, const vector<T>& Y, int64 mod) {        \
    vector<T> r(Y.size());                                                 \
    poly_mod(&X[0], (int)X.size(), &Y[0], (int)Y.size(), &r[0], mod);      \
    adjust_poly_leading_zero(r);                                           \
    return std::move(r);                                                   \
  }

template <typename T>
SL REQUIRES((is_native_integer<T>::value)) RETURN(void)
    poly_div_and_mod(const T* X, const int n, const T* Y, const int m, T* q,
                     T* r, int64 mod) {
  typedef typename std::make_unsigned<T>::type unsignedT;
  // This condition also includes the case n < m;
  if ((n - m) * m <= 1000) {
    poly_div_and_mod_normal_internal<unsignedT>(
        (const unsignedT*)X, n, (const unsignedT*)Y, m, (unsignedT*)q,
        (unsignedT*)r, mod);
  } else {
    poly_div_and_mod_dc_internal<unsignedT>((const unsignedT*)X, n,
                                            (const unsignedT*)Y, m,
                                            (unsignedT*)q, (unsignedT*)r, mod);
  }
}

template <typename T>
SL REQUIRES((is_native_integer<T>::value)) RETURN(tuple<vector<T>, vector<T>>)
    poly_div_and_mod(const vector<T>& X, const vector<T>& Y, int64 mod) {
  const int n = (int)X.size() - 1;
  const int m = (int)Y.size() - 1;

  vector<T> q(max(n - m + 1, 1));
  vector<T> r(m + 1);
  poly_div_and_mod(&X[0], n + 1, &Y[0], m + 1, &q[0], &r[0], mod);

  r[m] = 0;
  adjust_poly_leading_zero(r);
  return make_tuple(std::move(q), std::move(r));
}

POLY_DIV_AND_MOD_IMPL(poly_div_and_mod_dc, poly_div_and_mod_dc_internal)
POLY_DIV_IMPL(poly_div_dc, poly_div_and_mod_dc)
POLY_MOD_IMPL(poly_mod_dc, poly_div_and_mod_dc)

POLY_DIV_AND_MOD_IMPL(poly_div_and_mod_normal, poly_div_and_mod_normal_internal)
POLY_DIV_IMPL(poly_div_normal, poly_div_and_mod_normal)
POLY_MOD_IMPL(poly_mod_normal, poly_div_and_mod_normal)

POLY_DIV_IMPL(poly_div, poly_div_and_mod)
POLY_MOD_IMPL(poly_mod, poly_div_and_mod)

struct NModPoly {
  int64 mod;
  std::vector<int64> data;

  NModPoly(int64 mod = 1) : mod(mod) {}

  NModPoly(const std::vector<int64>& data, int64 mod, int adjustLeadingZero = 1)
      : data(data), mod(mod) {
    adjust_mod();
    if (adjustLeadingZero) {
      adjust_leading_zeros();
    }
  }

  NModPoly(std::vector<int64>&& data, int64 mod, int adjustLeadingZero = 1)
      : data(std::move(data)), mod(mod) {
    adjust_mod();
    if (adjustLeadingZero) {
      adjust_leading_zeros();
    }
  }

  NModPoly& operator=(const vector<int64>& v) {
    data = v;
    return *this;
  }

  NModPoly& operator=(const vector<int64>&& v) {
    data = v;
    return *this;
  }

  NModPoly(const NModPoly& p) = default;
  NModPoly(NModPoly&& p) = default;
  NModPoly& operator=(const NModPoly& other) = default;
  NModPoly& operator=(NModPoly&& other) = default;

  NModPoly& adjust_leading_zeros() {
    adjust_poly_leading_zero(data);
    return *this;
  }

  NModPoly& adjust_mod() {
    for (auto& iter : data) {
      iter = regulate_mod(iter, mod);
    }
    return *this;
  }

  int deg() const { return static_cast<int>(data.size() - 1); }
  int size() const { return static_cast<int>(data.size()); }

  NModPoly& resize(int n) {
    const int m = static_cast<int>(data.size());
    data.resize(n);
    for (int i = m; i < n; ++i) {
      data[i] = 0;
    }
    return *this;
  }

  NModPoly& redeg(int n) { return resize(n + 1); }

  int64& operator[](int idx) {
    PE_ASSERT(idx >= 0 && idx < data.size());
    return data[idx];
  }

  int64 operator[](int idx) const {
    PE_ASSERT(idx >= 0 && idx < data.size());
    return data[idx];
  }

  int64 at(int idx) const {
    return idx >= 0 && idx < data.size() ? data[idx] : 0;
  }

  bool isZero() const { return data.size() == 1 && data[0] == 0; }

  int64 valueAt(int64 v) const {
    int64 ret = 0;
    for (int i = deg(); i >= 0; --i) {
      ret = ret * v % mod + data[i];
      if (ret >= mod) ret -= mod;
    }
    return ret;
  }

  NModPoly lowerTerms(int n, int adjustLeadingZero = 1) const {
    const int m = min(n, static_cast<int>(data.size()));
    return NModPoly(std::vector<int64>(data.begin(), data.begin() + m), mod,
                    adjustLeadingZero);
  }

  NModPoly inv(int n) const;
};

template <int64 M>
struct NModPolyT : public NModPoly {
  NModPolyT() : NModPoly(M) {}

  NModPolyT(const std::vector<int64>& data) : NModPoly(data, M) {}

  NModPolyT(std::vector<int64>&& data) : NModPoly(std::move(data), M) {}

  NModPolyT(std::initializer_list<int64> l)
      : NModPolyT(std::vector<int64>(l)) {}
};

SL NModPoly poly_mul_normal(const NModPoly& X, const NModPoly& Y) {
  return NModPoly{poly_mul_normal(X.data, Y.data, X.mod), X.mod};
}

#if HAS_POLY_MUL_NTT
SL NModPoly poly_mul_ntt(const NModPoly& X, const NModPoly& Y) {
  return NModPoly{ntt::poly_mul_ntt(X.data, Y.data, X.mod), X.mod};
}
#endif

SL NModPoly poly_mul(const NModPoly& X, const NModPoly& Y) {
  return NModPoly{poly_mul(X.data, Y.data, X.mod), X.mod};
}

SL NModPoly poly_inv_mod(const NModPoly& x, int n) {
  // It is assumed that mod is a prime
  return NModPoly(poly_inv_mod(x.data, n, x.mod), x.mod);
}

SL tuple<NModPoly, NModPoly> poly_div_and_mod(const NModPoly& x,
                                              const NModPoly& y) {
  vector<int64> q, r;
  tie(q, r) = poly_div_and_mod(x.data, y.data, x.mod);
  return make_tuple(NModPoly(std::move(q), x.mod),
                    NModPoly(std::move(r), x.mod));
}

#define PPOLY_DIV_AND_MOD_IMPL(poly_div_and_mod, poly_div_and_mod_internal) \
  SL tuple<NModPoly, NModPoly> poly_div_and_mod(const NModPoly& X,          \
                                                const NModPoly& Y) {        \
    vector<int64> q, r;                                                     \
    tie(q, r) = poly_div_and_mod(X.data, Y.data, X.mod);                    \
    return make_tuple(NModPoly(std::move(q), X.mod),                        \
                      NModPoly(std::move(r), X.mod));                       \
  }

#define PPOLY_DIV_IMPL(poly_div, poly_div_and_mod)             \
  SL NModPoly poly_div(const NModPoly& X, const NModPoly& Y) { \
    return NModPoly(poly_div(X.data, Y.data, X.mod), X.mod);   \
  }

#define PPOLY_MOD_IMPL(poly_mod, poly_div_and_mod)             \
  SL NModPoly poly_mod(const NModPoly& X, const NModPoly& Y) { \
    return NModPoly(poly_mod(X.data, Y.data, X.mod), X.mod);   \
  }

PPOLY_DIV_AND_MOD_IMPL(poly_div_and_mod_dc, poly_div_and_mod_dc_internal)
PPOLY_DIV_IMPL(poly_div_dc, poly_div_and_mod_dc)
PPOLY_MOD_IMPL(poly_mod_dc, poly_div_and_mod_dc)

PPOLY_DIV_AND_MOD_IMPL(poly_div_and_mod_normal,
                       poly_div_and_mod_normal_internal)
PPOLY_DIV_IMPL(poly_div_normal, poly_div_and_mod_normal)
PPOLY_MOD_IMPL(poly_mod_normal, poly_div_and_mod_normal)

PPOLY_DIV_IMPL(poly_div, poly_div_and_mod)
PPOLY_MOD_IMPL(poly_mod, poly_div_and_mod)

inline NModPoly NModPoly::inv(int n) const {
  // It is assumed that mod is a prime
  auto t = poly_inv_mod(data, n, mod);
  return NModPoly(std::vector<int64>(static_cast<int64*>(&t[0]),
                                     static_cast<int64*>(&t[0]) + t.size()),
                  mod);
}

NModPoly operator<<(const NModPoly& p, int m) {
  if (m == 0) {
    return p;
  }
  std::vector<int64> new_data(p.data.size() + m);
  for (int i = static_cast<int>(p.data.size()) + m - 1; i >= m; --i) {
    new_data[i] = p.data[i - m];
  }
  for (int i = 0; i < m; ++i) {
    new_data[i] = 0;
  }
  return NModPoly(std::move(new_data), p.mod);
}

SL NModPoly operator-(const NModPoly& x, const NModPoly& y) {
  return NModPoly(poly_sub(x.data, y.data, x.mod), x.mod)
      .adjust_leading_zeros();
}

SL NModPoly operator+(const NModPoly& x, const NModPoly& y) {
  return NModPoly(poly_add(x.data, y.data, x.mod), x.mod)
      .adjust_leading_zeros();
}

SL NModPoly operator*(const NModPoly& x, int64 v) {
  std::vector<int64> data(x.data);
  for (auto& iter : data) {
    iter = iter * v % x.mod;
  }
  return NModPoly(std::move(data), x.mod);
}

SL NModPoly operator*(int64 v, const NModPoly& x) { return x * v; }

SL NModPoly operator*(const NModPoly& x, const NModPoly& y) {
  return poly_mul(x, y);
}

SL NModPoly operator/(const NModPoly& x, const NModPoly& y) {
  return poly_div(x, y);
}

SL NModPoly operator%(const NModPoly& x, const NModPoly& y) {
  return poly_mod(x, y);
}

SL int operator==(const NModPoly& x, const NModPoly& y) {
  return x.mod == y.mod && x.data == y.data;
}

// x^n % mod
SL NModPoly operator%(int64 n, const NModPoly& mod) {
  NModPoly x{{0, 1}, mod.mod};
  NModPoly ret{{1}, mod.mod};
  for (; n > 0; n >>= 1) {
    if (n & 1) {
      ret = poly_mod(x * ret, mod);
    }
    if (n > 1) {
      x = poly_mod(x * x, mod);
    }
  }
  return ret;
}

SL ostream& operator<<(ostream& o, const NModPoly& p) {
  const int n = static_cast<int>(p.data.size());
  for (int i = 0; i < n - 1; ++i) {
    o << p.data[i] << ", ";
  }
  return o << p.data[n - 1];
}

#endif
