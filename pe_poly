#ifndef __PE_POLY__
#define __PE_POLY__

#include "pe_base"
#include "pe_integer_util"
#include "pe_mod"
#include "pe_ntt"
#include "pe_poly_algo"

int64 DEFAULT_POLY_MOD = 1;

struct NModPoly {
  int64 mod;
  std::vector<int64> data;

  NModPoly(int64 mod = 0) : mod(mod == 0 ? DEFAULT_POLY_MOD : mod) {}

  NModPoly(const std::vector<int64>& data, int64 mod = 0)
      : data(data), mod(mod == 0 ? DEFAULT_POLY_MOD : mod) {
    adjust_mod().adjust_leading_zeros();
  }

  NModPoly(std::vector<int64>&& data, int64 mod = 0)
      : data(std::move(data)), mod(mod == 0 ? DEFAULT_POLY_MOD : mod) {
    adjust_mod().adjust_leading_zeros();
  }

  NModPoly& operator=(const vector<int64>& v) {
    data = v;
    return *this;
  }

  NModPoly& operator=(const vector<int64>&& v) {
    data = std::move(v);
    return *this;
  }

  NModPoly(const NModPoly& p) = default;
  NModPoly(NModPoly&& p) = default;
  NModPoly& operator=(const NModPoly& other) = default;
  NModPoly& operator=(NModPoly&& other) = default;

  NModPoly& adjust_leading_zeros() {
    adjust_poly_leading_zero(data);
    return *this;
  }

  NModPoly& adjust_mod() {
    for (auto& iter : data) {
      iter = regulate_mod(iter, mod);
    }
    return *this;
  }

  int deg() const { return static_cast<int>(data.size() - 1); }
  int size() const { return static_cast<int>(data.size()); }

  NModPoly& resize(int n) {
    const int m = (int)data.size();
    data.resize(n);
    for (int i = m; i < n; ++i) {
      data[i] = 0;
    }
    return *this;
  }

  NModPoly& redeg(int n) { return resize(n + 1); }

  int64& operator[](int idx) {
    PE_ASSERT(idx >= 0 && idx < data.size());
    return data[idx];
  }

  int64 operator[](int idx) const {
    PE_ASSERT(idx >= 0 && idx < data.size());
    return data[idx];
  }

  int64 at(int idx) const {
    return idx >= 0 && idx < data.size() ? data[idx] : 0;
  }

  bool isZero() const { return data.size() == 1 && data[0] == 0; }

  int64 valueAt(int64 v) const {
    int64 ret = 0;
    for (int i = deg(); i >= 0; --i) {
      ret = ret * v % mod + data[i];
      if (ret >= mod) ret -= mod;
    }
    return ret;
  }

  NModPoly lowerTerms(int n) const {
    const int m = min(n, static_cast<int>(data.size()));
    return NModPoly(std::vector<int64>(data.begin(), data.begin() + m), mod);
  }

  NModPoly inv(int n) const;
};

template <int64 M>
struct NModPolyT : public NModPoly {
  NModPolyT() : NModPoly(M) {}

  NModPolyT(const std::vector<int64>& data) : NModPoly(data, M) {}

  NModPolyT(std::vector<int64>&& data) : NModPoly(std::move(data), M) {}

  NModPolyT(std::initializer_list<int64> l) : NModPolyT(std::vector<int64>(l)) {}
};

SL NModPoly poly_mul_normal(const NModPoly& X, const NModPoly& Y) {
  return NModPoly{poly_mul_normal(X.data, Y.data, X.mod), X.mod};
}

#if HAS_POLY_MUL_NTT
SL NModPoly poly_mul_ntt(const NModPoly& X, const NModPoly& Y) {
  return NModPoly{ntt::poly_mul_ntt(X.data, Y.data, X.mod), X.mod};
}
#endif

SL NModPoly poly_mul(const NModPoly& X, const NModPoly& Y) {
  return NModPoly{poly_mul(X.data, Y.data, X.mod), X.mod};
}

SL NModPoly poly_inv_mod(const NModPoly& x, int n) {
  // It is assumed that mod is a prime
  return NModPoly(poly_inv_mod(x.data, n, x.mod), x.mod);
}

SL tuple<NModPoly, NModPoly> poly_div_and_mod(const NModPoly& x, const NModPoly& y) {
  vector<int64> q, r;
  tie(q, r) = poly_div_and_mod(x.data, y.data, x.mod);
  return make_tuple(NModPoly(std::move(q), x.mod), NModPoly(std::move(r), x.mod));
}

#define PPOLY_DIV_AND_MOD_IMPL(poly_div_and_mod, poly_div_and_mod_internal)  \
  SL tuple<NModPoly, NModPoly> poly_div_and_mod(const NModPoly& X, const NModPoly& Y) {      \
    vector<int64> q, r;                                                      \
    tie(q, r) = poly_div_and_mod(X.data, Y.data, X.mod);                     \
    return make_tuple(NModPoly(std::move(q), X.mod), NModPoly(std::move(r), X.mod)); \
  }

#define PPOLY_DIV_IMPL(poly_div, poly_div_and_mod)       \
  SL NModPoly poly_div(const NModPoly& X, const NModPoly& Y) {       \
    return NModPoly(poly_div(X.data, Y.data, X.mod), X.mod); \
  }

#define PPOLY_MOD_IMPL(poly_mod, poly_div_and_mod)       \
  SL NModPoly poly_mod(const NModPoly& X, const NModPoly& Y) {       \
    return NModPoly(poly_mod(X.data, Y.data, X.mod), X.mod); \
  }

PPOLY_DIV_AND_MOD_IMPL(poly_div_and_mod_dc, poly_div_and_mod_dc_internal)
PPOLY_DIV_IMPL(poly_div_dc, poly_div_and_mod_dc)
PPOLY_MOD_IMPL(poly_mod_dc, poly_div_and_mod_dc)

PPOLY_DIV_AND_MOD_IMPL(poly_div_and_mod_normal,
                       poly_div_and_mod_normal_internal)
PPOLY_DIV_IMPL(poly_div_normal, poly_div_and_mod_normal)
PPOLY_MOD_IMPL(poly_mod_normal, poly_div_and_mod_normal)

PPOLY_DIV_IMPL(poly_div, poly_div_and_mod)
PPOLY_MOD_IMPL(poly_mod, poly_div_and_mod)

inline NModPoly NModPoly::inv(int n) const {
  // It is assumed that mod is a prime
  auto t = poly_inv_mod(data, n, mod);
  return NModPoly(std::vector<int64>((int64*)&t[0], (int64*)&t[0] + t.size()), mod);
}

NModPoly operator<<(const NModPoly& p, int m) {
  if (m == 0) {
    return p;
  }
  std::vector<int64> new_data(p.data.size() + m);
  for (int i = static_cast<int>(p.data.size()) + m - 1; i >= m; --i) {
    new_data[i] = p.data[i - m];
  }
  for (int i = 0; i < m; ++i) {
    new_data[i] = 0;
  }
  return NModPoly(std::move(new_data), p.mod);
}

SL NModPoly operator-(const NModPoly& x, const NModPoly& y) {
  return NModPoly(poly_sub(x.data, y.data, x.mod), x.mod).adjust_leading_zeros();
}

SL NModPoly operator+(const NModPoly& x, const NModPoly& y) {
  return NModPoly(poly_add(x.data, y.data, x.mod), x.mod).adjust_leading_zeros();
}

SL NModPoly operator*(const NModPoly& x, int64 v) {
  std::vector<int64> data(x.data);
  for (auto& iter : data) {
    iter = iter * v % x.mod;
  }
  return NModPoly(std::move(data), x.mod);
}

SL NModPoly operator*(int64 v, const NModPoly& x) { return x * v; }

SL NModPoly operator*(const NModPoly& x, const NModPoly& y) { return poly_mul(x, y); }

SL NModPoly operator/(const NModPoly& x, const NModPoly& y) { return poly_div(x, y); }

SL NModPoly operator%(const NModPoly& x, const NModPoly& y) { return poly_mod(x, y); }

SL int operator==(const NModPoly& x, const NModPoly& y) {
  return x.mod == y.mod && x.data == y.data;
}

// x^n % mod
SL NModPoly operator%(int64 n, const NModPoly& mod) {
  NModPoly x{{0, 1}, mod.mod};
  NModPoly ret{{1}, mod.mod};
  for (; n > 0; n >>= 1) {
    if (n & 1) {
      ret = poly_mod(x * ret, mod);
    }
    if (n > 1) {
      x = poly_mod(x * x, mod);
    }
  }
  return ret;
}

SL ostream& operator<<(ostream& o, const NModPoly& p) {
  const int n = p.data.size();
  for (int i = 0; i < n - 1; ++i) {
    o << p.data[i] << ", ";
  }
  return o << p.data[n - 1];
}

// size x = size v
SL vector<int64> poly_evaluate_mod_normal(const NModPoly& X,
                                          const vector<int64>& V) {
  return poly_evaluate_mod_normal(X.data, V, X.mod);
}

// size x = size v
SL vector<int64> poly_evaluate_mod_bls(const NModPoly& X, const vector<int64>& V) {
  return poly_evaluate_mod_bls(X.data, V, X.mod);
}

// gf_first, gf_at is good for the case size(A) is small.
// Otherwise, A.inv(n) * B is better.

// Finds the coefficient of x^0..x^n of f such that: A*f = B
// Returns empty vector if there is no integer solution.
// O(size(A) * n)
SL vector<int64> gf_first(const NModPoly& A, const NModPoly& B, const int n) {
  return gf_first(A.data, B.data, n, A.mod);
}

// Finds the coefficient of x^n of f such that: A*f = B
// Returns -1 if there is no integer solution.
// O(size(A)^3 * log n) for big n
SL int64 gf_at(const NModPoly& A, const NModPoly& B, const int64 n) {
  return gf_at(A.data, B.data, n, A.mod);
}

// Berlekamp Massey
SL NModPoly find_minimal_poly(const NModPoly& s) {
  const int m = s.data.size();
  const int n = m >> 1;
  const int64 mod = s.mod;
  PE_ASSERT(n * 2 == m);

  NModPoly r0{{1}, mod};
  r0 = r0 << m;
  NModPoly r1(s);
  NModPoly v0{{0}, mod};
  NModPoly v1{{1}, mod};

  while (n + 1 <= r1.deg()) {
    NModPoly q, r;
    tie(q, r) = poly_div_and_mod(r0, r1);
    NModPoly v(v0 - q * v1);
    v0 = std::move(v1);
    v1 = std::move(v);
    r0 = std::move(r1);
    r1 = std::move(r);
  }
  v1 = std::move(inv_of(v1[0], mod) * v1);
  reverse(v1.data.begin(), v1.data.end());
  return v1;
}

SL int64 nth_element(const NModPoly& s, int64 n, const NModPoly& min_poly) {
  if (n <= s.deg()) {
    return s[n];
  }

  auto r = n % min_poly;
  const int m = r.deg();
  int64 ans = 0;
  for (int i = 0; i <= m; ++i) {
    ans = add_mod(ans, s[i] * r[i] % s.mod, s.mod);
  }
  return ans;
}

SL NModPoly find_linear_recurrence(const NModPoly& s) {
  const int len = s.data.size();
  for (int n = 2; n < len; n += 2) {
    auto use = s.lowerTerms(n);
    auto min_poly = find_minimal_poly(use);
    int ok = 1;
    for (int i = n; i < len; ++i) {
      auto value = nth_element(use, i, min_poly);
      if (value != s[i]) {
        ok = 0;
        break;
      }
    }
    if (ok) {
      return min_poly;
    }
  }
  return NModPoly();
}

SL int64 nth_element(const NModPoly& s, int64 n) {
  if (n <= s.deg()) {
    return s[n];
  }

  auto min_poly = find_linear_recurrence(s);
  if (min_poly.deg() > 0) {
    return nth_element(s, n, min_poly);
  }
  return -1;
}
#endif
